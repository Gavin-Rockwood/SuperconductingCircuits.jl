import{_ as u,C as r,c as p,o as d,j as i,G as n,a as l,w as s}from"./chunks/framework._0W__P8I.js";const z=JSON.parse('{"title":"SuperconductingCircuits.jl Documentation","description":"","frontmatter":{},"headers":[],"relativePath":"resources/api.md","filePath":"resources/api.md","lastUpdated":null}'),g={name:"resources/api.md"},c={class:"jldocstring custom-block",open:""},h={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},q={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},O={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""},H={class:"jldocstring custom-block",open:""},Q={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},L={class:"jldocstring custom-block",open:""};function U(M,t,I,N,P,G){const e=r("Badge"),o=r("PluginTabsTab"),a=r("PluginTabs");return d(),p("div",null,[t[277]||(t[277]=i("h1",{id:"SuperconductingCircuits.jl-Documentation",tabindex:"-1"},[l("SuperconductingCircuits.jl Documentation "),i("a",{class:"header-anchor",href:"#SuperconductingCircuits.jl-Documentation","aria-label":'Permalink to "SuperconductingCircuits.jl Documentation {#SuperconductingCircuits.jl-Documentation}"'},"​")],-1)),n(a,null,{default:s(()=>[n(o,{label:"Circuits"},{default:s(()=>[t[132]||(t[132]=i("h2",{id:"Circuits",tabindex:"-1"},[l("Circuits "),i("a",{class:"header-anchor",href:"#Circuits","aria-label":'Permalink to "Circuits {#Circuits}"'},"​")],-1)),i("details",c,[i("summary",null,[t[0]||(t[0]=i("a",{id:"SuperconductingCircuits.Circuits.Circuit",href:"#SuperconductingCircuits.Circuits.Circuit"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.Circuit")],-1)),t[1]||(t[1]=l()),n(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),t[3]||(t[3]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"Circuit")])])])],-1)),t[4]||(t[4]=i("p",null,"A structure representing a quantum circuit in the SuperconductingCircuits framework.",-1)),t[5]||(t[5]=i("p",null,[i("strong",null,"Fields")],-1)),t[6]||(t[6]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"H_op::qt.QuantumObject"),l(": The Hamiltonian operator describing the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"dressed_energies::Dict"),l(": Dictionary containing the dressed energy levels of the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"dressed_states::Dict"),l(": Dictionary containing the dressed quantum states of the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"dims::Tuple"),l(": Tuple specifying the dimensions of the circuit's Hilbert space.")])]),i("li",null,[i("p",null,[i("code",null,"order::Vector"),l(": Vector specifying the order of components or subsystems in the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"loss_ops::Dict{String, qt.QuantumObject}"),l(": Dictionary mapping loss channel names to their corresponding quantum operators.")])]),i("li",null,[i("p",null,[i("code",null,"components::Dict{String, Any}"),l(": Dictionary of circuit components, keyed by name.")])]),i("li",null,[i("p",null,[i("code",null,"interactions::Vector"),l(": Vector of interactions present in the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"stuff::Dict{String, Any}"),l(": Miscellaneous circuit-related data.")])]),i("li",null,[i("p",null,[i("code",null,"drives::Dict{String, Any}"),l(": Dictionary of drive terms applied to the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"gates::Dict{String, Any}"),l(": Dictionary of quantum gates defined for the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"ops::Dict{String, Any}"),l(": Dictionary of additional operators relevant to the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"io_stuff::Dict{String, Any}"),l(": Dictionary containing input/output related information.")])]),i("li",null,[i("p",null,[i("code",null,"dressed_order::Vector"),l(": Vector specifying the order of dressed states or subsystems.")])])],-1)),t[7]||(t[7]=i("p",null,[i("strong",null,"Description")],-1)),t[8]||(t[8]=i("p",null,[l("The "),i("code",null,"Circuit"),l(" struct encapsulates all relevant information for modeling, simulating, and analyzing a superconducting quantum circuit, including its Hamiltonian, components, interactions, and various operators.")],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[2]||(t[2]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/Circuits.jl#L24-L47",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[2]})]),i("details",h,[i("summary",null,[t[9]||(t[9]=i("a",{id:"SuperconductingCircuits.Circuits.init_circuit-Tuple{AbstractArray{SuperconductingCircuits.Circuits.Component}, Any}",href:"#SuperconductingCircuits.Circuits.init_circuit-Tuple{AbstractArray{SuperconductingCircuits.Circuits.Component}, Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.init_circuit")],-1)),t[10]||(t[10]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[12]||(t[12]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"init_circuit"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(components"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"AbstractArray{Component}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", interactions; operators_to_add"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Dict{String, Any}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(), use_sparse"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"true"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", dressed_kwargs"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Dict{Symbol, Any}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"())")])])])],-1)),t[13]||(t[13]=i("p",null,"Initialize a quantum circuit from a list of components and their interactions.",-1)),t[14]||(t[14]=i("p",null,[i("strong",null,"Arguments")],-1)),t[15]||(t[15]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"components::AbstractArray{Component}"),l(": An array of "),i("code",null,"Component"),l(" objects representing the subsystems of the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"interactions"),l(": A collection describing the interactions between components. Each interaction is typically a tuple or array where the first element is the coupling strength and the remaining elements specify the operators for each component.")])]),i("li",null,[i("p",null,[i("code",null,"operators_to_add=Dict{String, Any}()"),l(": (Optional) A dictionary of additional operators to add to the circuit, keyed by operator name.")])]),i("li",null,[i("p",null,[i("code",null,"use_sparse=true"),l(": (Optional) If "),i("code",null,"true"),l(", use sparse matrix representations for operators and Hamiltonians.")])]),i("li",null,[i("p",null,[i("code",null,"dressed_kwargs=Dict{Symbol, Any}()"),l(": (Optional) Keyword arguments passed to the dressed state calculation, such as "),i("code",null,":f"),l(" (function for transformation) and "),i("code",null,":step_number"),l(" (number of steps).")])])],-1)),t[16]||(t[16]=i("p",null,[i("strong",null,"Returns")],-1)),t[17]||(t[17]=i("ul",null,[i("li",null,[i("code",null,"circuit::Circuit"),l(": An initialized "),i("code",null,"Circuit"),l(" object containing the Hamiltonian, dressed states and energies, loss operators, component dictionary, and other relevant circuit information.")])],-1)),t[18]||(t[18]=i("p",null,[i("strong",null,"Details")],-1)),t[19]||(t[19]=i("ul",null,[i("li",null,[i("p",null,"Constructs the total Hilbert space dimensions and identity operators for each component.")]),i("li",null,[i("p",null,[l("Builds the bare Hamiltonian ("),i("code",null,"H_op_0"),l(") and adds interaction terms to form the full Hamiltonian ("),i("code",null,"H_op"),l(").")])]),i("li",null,[i("p",null,[l("Calculates dressed states and energies using "),i("code",null,"get_dressed_states"),l(".")])]),i("li",null,[i("p",null,"Assembles loss operators for each component.")]),i("li",null,[i("p",null,[l("Organizes components and other circuit data into a "),i("code",null,"Circuit"),l(" struct.")])]),i("li",null,[i("p",null,"Optionally adds user-specified operators to the circuit.")])],-1)),t[20]||(t[20]=i("hr",null,null,-1)),t[21]||(t[21]=i("hr",null,null,-1)),t[22]||(t[22]=i("p",null,[i("strong",null,"Overloaded As:")],-1)),t[23]||(t[23]=i("hr",null,null,-1)),t[24]||(t[24]=i("p",null,[i("strong",null,"init_circuit(components::AbstractArray{Dict}, types, interactions; kwargs...)")],-1)),t[25]||(t[25]=i("p",null,"Instead of taking in a list of initialized circuit elements, this takes in a list of parameter dictionaries and a list of of the corresponding circuit element types instead.",-1)),t[26]||(t[26]=i("p",null,[i("strong",null,"Arguments")],-1)),t[27]||(t[27]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"components::AbstractArray{Dict}"),l(": An array of dictionaries, each containing the parameters for a circuit component.")])]),i("li",null,[i("p",null,[i("code",null,"types"),l(": An array specifying the type of each component, used to select the appropriate constructor from "),i("code",null,"Component_inits"),l(".")])]),i("li",null,[i("p",null,[i("code",null,"interactions"),l(": Data structure describing the interactions between components.")])]),i("li",null,[i("p",null,[i("code",null,"kwargs..."),l(": Additional keyword arguments passed to the underlying "),i("code",null,"init_circuit"),l(" method.")])])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[11]||(t[11]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/CircuitConstructor.jl#L1-L36",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[11]})]),t[133]||(t[133]=i("h2",{id:"Components",tabindex:"-1"},[l("Components "),i("a",{class:"header-anchor",href:"#Components","aria-label":'Permalink to "Components {#Components}"'},"​")],-1)),t[134]||(t[134]=i("h3",{id:"Qubit",tabindex:"-1"},[l("Qubit "),i("a",{class:"header-anchor",href:"#Qubit","aria-label":'Permalink to "Qubit {#Qubit}"'},"​")],-1)),i("details",k,[i("summary",null,[t[28]||(t[28]=i("a",{id:"SuperconductingCircuits.Circuits.Qubit",href:"#SuperconductingCircuits.Circuits.Qubit"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.Qubit")],-1)),t[29]||(t[29]=l()),n(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),t[31]||(t[31]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"Qubit")])])])],-1)),t[32]||(t[32]=i("p",null,"A structure representing a quantum bit (qubit) component in a superconducting circuit.",-1)),t[33]||(t[33]=i("p",null,[i("strong",null,"Fields")],-1)),t[34]||(t[34]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"dim::Int"),l(": The Hilbert space dimension of the qubit (Always 2).")])]),i("li",null,[i("p",null,[i("code",null,"params::Dict"),l(": Dictionary containing the physical parameters of the qubit.")])]),i("li",null,[i("p",null,[i("code",null,"H_op::qt.QuantumObject"),l(": The Hamiltonian operator of the qubit, represented as a quantum object.")])]),i("li",null,[i("p",null,[i("code",null,"eigenstates::Vector"),l(": Vector containing the eigenstates of the qubit Hamiltonian.")])]),i("li",null,[i("p",null,[i("code",null,"eigenenergies::Vector"),l(": Vector containing the eigenenergies corresponding to the eigenstates.")])]),i("li",null,[i("p",null,[i("code",null,"loss_ops::Dict"),l(": Dictionary of loss (dissipation) operators associated with the qubit.")])]),i("li",null,[i("p",null,[i("code",null,"freq::Float64"),l(": The transition frequency of the qubit.")])])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[30]||(t[30]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/Components/Qubit.jl#L1-L14",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[30]})]),i("details",m,[i("summary",null,[t[35]||(t[35]=i("a",{id:"SuperconductingCircuits.Circuits.init_qubit-Tuple{Any}",href:"#SuperconductingCircuits.Circuits.init_qubit-Tuple{Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.init_qubit")],-1)),t[36]||(t[36]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[38]||(t[38]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"init_qubit"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(freq; name "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},' "Qubit"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")])])])],-1)),t[39]||(t[39]=i("p",null,[l("Initialize a "),i("code",null,"Qubit"),l(" object with the specified transition frequency "),i("code",null,"freq"),l(".")],-1)),t[40]||(t[40]=i("p",null,[i("strong",null,"Arguments")],-1)),t[41]||(t[41]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"freq::Number"),l(": The transition frequency of the qubit.")])]),i("li",null,[i("p",null,[i("code",null,"name::String"),l(" (optional): The name of the qubit. Defaults to "),i("code",null,'"Qubit"'),l(".")])])],-1)),t[42]||(t[42]=i("p",null,[i("strong",null,"Returns")],-1)),t[43]||(t[43]=i("ul",null,[i("li",null,[i("code",null,"Qubit"),l(": An initialized "),i("code",null,"Qubit"),l(" object containing the Hamiltonian operator, eigenenergies, eigenstates, and other parameters.")])],-1)),t[44]||(t[44]=i("p",null,[i("strong",null,"Details")],-1)),t[45]||(t[45]=i("p",null,[l("The function constructs the qubit Hamiltonian as "),i("code",null,"H_op = freq * qt.sigmaz() / 2"),l(", computes its eigenenergies and eigenstates, and returns a "),i("code",null,"Qubit"),l(" object with these properties.")],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[37]||(t[37]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/Components/Qubit.jl#L29-L43",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[37]})]),i("details",y,[i("summary",null,[t[46]||(t[46]=i("a",{id:"SuperconductingCircuits.Circuits.init_qubit-Tuple{T} where T<:Dict",href:"#SuperconductingCircuits.Circuits.init_qubit-Tuple{T} where T<:Dict"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.init_qubit")],-1)),t[47]||(t[47]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[49]||(t[49]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"init_qubit"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(Params"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"T"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"where"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," T"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"<:"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Dict")])])])],-1)),t[50]||(t[50]=i("p",null,"Initializes a qubit using a dictionary of parameters.",-1)),t[51]||(t[51]=i("p",null,[i("strong",null,"Arguments")],-1)),t[52]||(t[52]=i("ul",null,[i("li",null,[i("code",null,"Params::Dict"),l(": A dictionary containing at least the key "),i("code",null,":freq"),l(" (the qubit frequency) and any additional keyword parameters required for qubit initialization.")])],-1)),t[53]||(t[53]=i("p",null,[i("strong",null,"Returns")],-1)),t[54]||(t[54]=i("ul",null,[i("li",null,[l("The result of calling "),i("code",null,"init_qubit"),l(" with the extracted frequency and remaining parameters.")])],-1)),t[55]||(t[55]=i("p",null,[i("strong",null,"Notes")],-1)),t[56]||(t[56]=i("ul",null,[i("li",null,[i("p",null,"The function makes a deep copy of the input dictionary to avoid mutating the original.")]),i("li",null,[i("p",null,[l("The "),i("code",null,":freq"),l(" key is extracted and removed from the dictionary before passing the remaining parameters as keyword arguments.")])])],-1)),t[57]||(t[57]=i("p",null,[i("strong",null,"Example")],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[48]||(t[48]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/Components/Qubit.jl#L54-L70",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[48]})]),t[135]||(t[135]=i("h3",{id:"Resonator",tabindex:"-1"},[l("Resonator "),i("a",{class:"header-anchor",href:"#Resonator","aria-label":'Permalink to "Resonator {#Resonator}"'},"​")],-1)),i("details",f,[i("summary",null,[t[58]||(t[58]=i("a",{id:"SuperconductingCircuits.Circuits.Resonator",href:"#SuperconductingCircuits.Circuits.Resonator"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.Resonator")],-1)),t[59]||(t[59]=l()),n(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),t[61]||(t[61]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"Resonator")])])])],-1)),t[62]||(t[62]=i("p",null,"A structure representing a quantum resonator component in a superconducting circuit.",-1)),t[63]||(t[63]=i("p",null,[i("strong",null,"Fields")],-1)),t[64]||(t[64]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"dim::Int"),l(": The Hilbert space dimension of the resonator.")])]),i("li",null,[i("p",null,[i("code",null,"params::Dict"),l(": Dictionary containing the physical parameters of the resonator.")])]),i("li",null,[i("p",null,[i("code",null,"H_op::qt.QuantumObject"),l(": The Hamiltonian operator of the resonator.")])]),i("li",null,[i("p",null,[i("code",null,"eigenstates::Vector"),l(": Vector of eigenstates of the resonator Hamiltonian.")])]),i("li",null,[i("p",null,[i("code",null,"eigenenergies::Vector"),l(": Vector of eigenenergies corresponding to the eigenstates.")])]),i("li",null,[i("p",null,[i("code",null,"loss_ops::Dict"),l(": Dictionary of loss (dissipation) operators associated with the resonator.")])]),i("li",null,[i("p",null,[i("code",null,"a_op::qt.QuantumObject"),l(": The annihilation (lowering) operator for the resonator.")])]),i("li",null,[i("p",null,[i("code",null,"N_op::qt.QuantumObject"),l(": The number operator for the resonator.")])])],-1)),t[65]||(t[65]=i("p",null,[i("strong",null,"Description")],-1)),t[66]||(t[66]=i("p",null,"This structure encapsulates all relevant quantum properties and operators for a resonator component, facilitating simulation and analysis within superconducting circuit models.",-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[60]||(t[60]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/Components/Resonator.jl#L2-L19",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[60]})]),t[136]||(t[136]=i("h3",{id:"SNAIL",tabindex:"-1"},[l("SNAIL "),i("a",{class:"header-anchor",href:"#SNAIL","aria-label":'Permalink to "SNAIL {#SNAIL}"'},"​")],-1)),t[137]||(t[137]=i("h3",{id:"Transmon",tabindex:"-1"},[l("Transmon "),i("a",{class:"header-anchor",href:"#Transmon","aria-label":'Permalink to "Transmon {#Transmon}"'},"​")],-1)),i("details",b,[i("summary",null,[t[67]||(t[67]=i("a",{id:"SuperconductingCircuits.Circuits.Transmon",href:"#SuperconductingCircuits.Circuits.Transmon"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.Transmon")],-1)),t[68]||(t[68]=l()),n(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),t[70]||(t[70]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"Transmon")])])])],-1)),t[71]||(t[71]=i("p",null,"A struct representing a transmon qubit component in a superconducting circuit.",-1)),t[72]||(t[72]=i("p",null,[i("strong",null,"Fields")],-1)),t[73]||(t[73]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"params::Dict"),l(": Dictionary containing the physical parameters of the transmon.")])]),i("li",null,[i("p",null,[i("code",null,"eigenenergies::Vector"),l(": Vector of eigenenergies computed for the transmon Hamiltonian.")])]),i("li",null,[i("p",null,[i("code",null,"eigenstates::Vector"),l(": Vector of eigenstates corresponding to the eigenenergies.")])]),i("li",null,[i("p",null,[i("code",null,"H_op::qt.QuantumObject"),l(": Truncated Hamiltonian operator for the transmon, represented as a quantum object.")])]),i("li",null,[i("p",null,[i("code",null,"dim::Int"),l(": Hilbert space dimension used for truncation.")])]),i("li",null,[i("p",null,[i("code",null,"loss_ops::Dict"),l(": Dictionary of loss (dissipation) operators relevant to the transmon.")])]),i("li",null,[i("p",null,[i("code",null,"H_op_full::qt.QuantumObject"),l(": Full (untruncated) Hamiltonian operator for the transmon.")])]),i("li",null,[i("p",null,[i("code",null,"n_op_full::qt.QuantumObject"),l(": Full (untruncated) charge operator (U(1) number operator).")])]),i("li",null,[i("p",null,[i("code",null,"n_op::qt.QuantumObject"),l(": Truncated charge operator.")])])],-1)),t[74]||(t[74]=i("p",null,[i("strong",null,"Description")],-1)),t[75]||(t[75]=i("p",null,[l("The "),i("code",null,"Transmon"),l(" struct encapsulates all relevant data and operators for simulating a transmon qubit, including its Hamiltonian, eigenstates, and loss mechanisms. It is designed for use in quantum circuit simulations and analysis.")],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[69]||(t[69]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/Components/Transmon.jl#L1-L19",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[69]})]),i("details",C,[i("summary",null,[t[76]||(t[76]=i("a",{id:"SuperconductingCircuits.Circuits.init_transmon-NTuple{4, Any}",href:"#SuperconductingCircuits.Circuits.init_transmon-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.init_transmon")],-1)),t[77]||(t[77]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[79]||(t[79]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"init_transmon"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(EC, EJ, N_full, N; name "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},' "Transmon"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", ng "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," 0"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", kappa_c "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," 1"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"/"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"("),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"56"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"*"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"1000"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"), kappa_d "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," 1.2348024316109425e-5"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")])])])],-1)),t[80]||(t[80]=i("p",null,"Initialize a Transmon qubit Hamiltonian and associated operators.",-1)),t[81]||(t[81]=i("p",null,[i("strong",null,"Arguments")],-1)),t[82]||(t[82]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"EC::Real"),l(": Charging energy of the transmon.")])]),i("li",null,[i("p",null,[i("code",null,"EJ::Real"),l(": Josephson energy of the transmon.")])]),i("li",null,[i("p",null,[i("code",null,"N_full::Int"),l(": Number of charge states to include in the full Hilbert space (dimension will be "),i("code",null,"2*N_full+1"),l(").")])]),i("li",null,[i("p",null,[i("code",null,"N::Int"),l(": Number of energy levels to keep in the truncated Hilbert space.")])]),i("li",null,[i("p",null,[i("code",null,"name::String"),l(": (Optional) Name of the transmon instance. Defaults to "),i("code",null,'"Transmon"'),l(".")])]),i("li",null,[i("p",null,[i("code",null,"ng::Real"),l(": (Optional) Offset charge. Defaults to "),i("code",null,"0"),l(".")])]),i("li",null,[i("p",null,[i("code",null,"kappa_c::Real"),l(": (Optional) Collapse (relaxation) rate. Defaults to "),i("code",null,"1/(56*1000)"),l(".")])]),i("li",null,[i("p",null,[i("code",null,"kappa_d::Real"),l(": (Optional) Dephasing rate. Defaults to "),i("code",null,"1.2348024316109425e-5"),l(".")])])],-1)),t[83]||(t[83]=i("p",null,[i("strong",null,"Returns")],-1)),t[84]||(t[84]=i("ul",null,[i("li",null,[i("code",null,"Transmon"),l(": An instance of the "),i("code",null,"Transmon"),l(" type containing: "),i("ul",null,[i("li",null,[i("p",null,[i("code",null,"params"),l(": Dictionary of parameters used for initialization.")])]),i("li",null,[i("p",null,[i("code",null,"dim"),l(": Truncated Hilbert space dimension.")])]),i("li",null,[i("p",null,[i("code",null,"H_op_full"),l(": Full Hamiltonian operator.")])]),i("li",null,[i("p",null,[i("code",null,"H_op"),l(": Truncated Hamiltonian operator.")])]),i("li",null,[i("p",null,[i("code",null,"n_op_full"),l(": Full number operator.")])]),i("li",null,[i("p",null,[i("code",null,"n_op"),l(": Truncated number operator.")])]),i("li",null,[i("p",null,[i("code",null,"eigenenergies"),l(": Eigenenergies of the truncated Hamiltonian.")])]),i("li",null,[i("p",null,[i("code",null,"eigenstates"),l(": Eigenstates of the truncated Hamiltonian.")])]),i("li",null,[i("p",null,[i("code",null,"loss_ops"),l(": Dictionary of collapse ("),i("code",null,'"Collapse"'),l(") and dephasing ("),i("code",null,'"Dephasing"'),l(") operators.")])])])])],-1)),t[85]||(t[85]=i("p",null,[i("strong",null,"Notes")],-1)),t[86]||(t[86]=i("ul",null,[i("li",null,[i("p",null,[l("The function constructs the transmon Hamiltonian in the charge basis, diagonalizes it, and projects onto the lowest "),i("code",null,"N"),l(" energy eigenstates.")])]),i("li",null,[i("p",null,"Collapse and dephasing operators are constructed in the truncated basis.")]),i("li",null,[i("p",null,"Hermiticity of operators is checked and enforced.")])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[78]||(t[78]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/Components/Transmon.jl#L35-L66",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[78]})]),i("details",E,[i("summary",null,[t[87]||(t[87]=i("a",{id:"SuperconductingCircuits.Circuits.init_transmon-Tuple{T} where T<:Dict",href:"#SuperconductingCircuits.Circuits.init_transmon-Tuple{T} where T<:Dict"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.init_transmon")],-1)),t[88]||(t[88]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[90]||(t[90]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"init_transmon"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(Params"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"T"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"where"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," T"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"<:"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Dict")])])])],-1)),t[91]||(t[91]=i("p",null,"Initialize a transmon qubit using a dictionary of parameters.",-1)),t[92]||(t[92]=i("p",null,[i("strong",null,"Arguments")],-1)),t[93]||(t[93]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"Params::Dict"),l(": A dictionary containing the following required keys:")]),i("ul",null,[i("li",null,[i("p",null,[i("code",null,":EC"),l(": Charging energy.")])]),i("li",null,[i("p",null,[i("code",null,":EJ"),l(": Josephson energy.")])]),i("li",null,[i("p",null,[i("code",null,":N_full"),l(": Total number of charge states.")])]),i("li",null,[i("p",null,[i("code",null,":N"),l(": Number of charge states to use in the truncated basis.")])])]),i("p",null,[l("Any additional keyword arguments in the dictionary will be forwarded to the underlying "),i("code",null,"init_transmon"),l(" method.")])])],-1)),t[94]||(t[94]=i("p",null,[i("strong",null,"Returns")],-1)),t[95]||(t[95]=i("ul",null,[i("li",null,[l("An initialized transmon object (type depends on the implementation of "),i("code",null,"init_transmon"),l(").")])],-1)),t[96]||(t[96]=i("p",null,[i("strong",null,"Notes")],-1)),t[97]||(t[97]=i("ul",null,[i("li",null,[l("The function extracts required parameters from the dictionary and passes them, along with any remaining parameters, to the lower-level "),i("code",null,"init_transmon"),l(" constructor.")])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[89]||(t[89]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/Components/Transmon.jl#L131-L149",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[89]})]),t[138]||(t[138]=i("h2",{id:"Utils",tabindex:"-1"},[l("Utils "),i("a",{class:"header-anchor",href:"#Utils","aria-label":'Permalink to "Utils {#Utils}"'},"​")],-1)),i("details",v,[i("summary",null,[t[98]||(t[98]=i("a",{id:"SuperconductingCircuits.Circuits.add_operator!-Tuple{SuperconductingCircuits.Circuits.Circuit, AbstractArray{String}, String}",href:"#SuperconductingCircuits.Circuits.add_operator!-Tuple{SuperconductingCircuits.Circuits.Circuit, AbstractArray{String}, String}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.add_operator!")],-1)),t[99]||(t[99]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[101]||(t[101]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"add_operator!"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(circuit"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Circuit"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", operator"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"AbstractArray{String}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", name"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"String"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"; use_sparse"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"true"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")])])])],-1)),t[102]||(t[102]=i("p",null,[l("Adds a custom operator to the given "),i("code",null,"circuit"),l(" object.")],-1)),t[103]||(t[103]=i("p",null,[i("strong",null,"Arguments")],-1)),t[104]||(t[104]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"circuit::Circuit"),l(": The circuit to which the operator will be added.")])]),i("li",null,[i("p",null,[i("code",null,"operator::AbstractArray{String}"),l(": An array of operator strings, one for each component in the circuit. The length must match the number of components in the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"name::String"),l(": The name under which the operator will be stored in the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"use_sparse"),l(" (optional, default = "),i("code",null,"true"),l("): Whether to convert the operator matrices to sparse format.")])])],-1)),t[105]||(t[105]=i("p",null,[i("strong",null,"Description")],-1)),t[106]||(t[106]=i("p",null,[l("For each component in the circuit, parses and evaluates the corresponding operator string. If the operator is not defined ("),i("code",null,"nothing"),l("), uses the identity operator for that component. Optionally converts each operator to a sparse matrix. The resulting operators are combined using a tensor product and stored in the circuit's "),i("code",null,"ops"),l(" dictionary under the given "),i("code",null,"name"),l(". The original operator definitions are also stored in "),i("code",null,'circuit.stuff["ops_def"]'),l(".")],-1)),t[107]||(t[107]=i("p",null,[i("strong",null,"Throws")],-1)),t[108]||(t[108]=i("ul",null,[i("li",null,[l("An error if the length of "),i("code",null,"operator"),l(" does not match the number of components in the circuit.")])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[100]||(t[100]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/CircuitUtils.jl#L1-L17",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[100]})]),i("details",j,[i("summary",null,[t[109]||(t[109]=i("a",{id:"SuperconductingCircuits.Circuits.get_dressed_states-Tuple{QuantumToolbox.QuantumObject, AbstractArray{SuperconductingCircuits.Circuits.Component}, Any}",href:"#SuperconductingCircuits.Circuits.get_dressed_states-Tuple{QuantumToolbox.QuantumObject, AbstractArray{SuperconductingCircuits.Circuits.Component}, Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.get_dressed_states")],-1)),t[110]||(t[110]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[112]||(t[112]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"get_dressed_states"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(H0"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"qt.QuantumObject"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", components"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"AbstractArray{Component}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", interactions; step_number"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"20"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", f"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"x"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"->"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"x"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"^"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"3"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")])])])],-1)),t[113]||(t[113]=i("p",null,"Compute the dressed states, energies, and orderings for a quantum system as interaction strengths are adiabatically turned on.",-1)),t[114]||(t[114]=i("p",null,[i("strong",null,"Arguments")],-1)),t[115]||(t[115]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"H0::qt.QuantumObject"),l(": The initial (bare) Hamiltonian of the system.")])]),i("li",null,[i("p",null,[i("code",null,"components::AbstractArray{Component}"),l(": Array of system components, each with a defined Hilbert space dimension and eigenstates.")])]),i("li",null,[i("p",null,[i("code",null,"interactions"),l(': List of interaction specifications. Each interaction is an array where the first element is the coupling strength, and subsequent elements specify operators (or "1" for identity) for each component. The string "hc" can be included to add the Hermitian conjugate.')])]),i("li",null,[i("p",null,[i("code",null,"step_number"),l(": (Optional) Number of steps in the adiabatic interpolation. Default is 20.")])]),i("li",null,[i("p",null,[i("code",null,"f"),l(": (Optional) Function mapping the interpolation parameter (from 0 to 1) to the interaction scaling. Default is "),i("code",null,"x -> x^3"),l(".")])])],-1)),t[116]||(t[116]=i("p",null,[i("strong",null,"Returns")],-1)),t[117]||(t[117]=i("p",null,"A vector containing:",-1)),t[118]||(t[118]=i("ol",null,[i("li",null,[i("p",null,[i("code",null,"dressed_states::Dict"),l(": Mapping from bare state tuples to the corresponding dressed state at the final step.")])]),i("li",null,[i("p",null,[i("code",null,"dressed_energies::Dict"),l(": Mapping from bare state tuples to the corresponding dressed energy at the final step.")])]),i("li",null,[i("p",null,[i("code",null,"dressed_order::Vector{Tuple}"),l(": Vector mapping the dressed state order (by energy) to the bare state tuple.")])])],-1)),t[119]||(t[119]=i("p",null,[i("strong",null,"Description")],-1)),t[120]||(t[120]=i("p",null,[l("The function interpolates between the bare Hamiltonian and the fully interacting Hamiltonian by scaling the interaction terms according to "),i("code",null,"f"),l(". At each step, it computes the eigenstates and energies, tracks the evolution of each bare state, and returns the dressed states, energies, and their order at the final step.")],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[111]||(t[111]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/CircuitUtils.jl#L39-L59",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[111]})]),i("details",F,[i("summary",null,[t[121]||(t[121]=i("a",{id:"SuperconductingCircuits.Circuits.save-Tuple{SuperconductingCircuits.Circuits.Circuit, String}",href:"#SuperconductingCircuits.Circuits.save-Tuple{SuperconductingCircuits.Circuits.Circuit, String}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.save")],-1)),t[122]||(t[122]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[124]||(t[124]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"save"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(circuit"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Circuit"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", filename"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"String"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")])])])],-1)),t[125]||(t[125]=i("p",null,[l("Serialize and save the given "),i("code",null,"circuit"),l(" object to a file specified by "),i("code",null,"filename"),l(".")],-1)),t[126]||(t[126]=i("p",null,[l("The function collects the following information from the "),i("code",null,"circuit"),l(":")],-1)),t[127]||(t[127]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"order"),l(": The order of the circuit.")])]),i("li",null,[i("p",null,[i("code",null,"components"),l(": A dictionary mapping component names to their parameters.")])]),i("li",null,[i("p",null,[i("code",null,"interactions"),l(": A list of circuit interactions.")])]),i("li",null,[i("p",null,[i("code",null,"stuff"),l(": Additional circuit data stored in the "),i("code",null,"stuff"),l(" field.")])])],-1)),t[128]||(t[128]=i("p",null,[i("strong",null,"Arguments")],-1)),t[129]||(t[129]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"circuit::Circuit"),l(": The circuit object to be saved.")])]),i("li",null,[i("p",null,[i("code",null,"filename::String"),l(": The path to the file where the circuit data will be saved.")])])],-1)),t[130]||(t[130]=i("p",null,[i("strong",null,"Note")],-1)),t[131]||(t[131]=i("p",null,"The actual file writing operation is not implemented in this function.",-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[123]||(t[123]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Circuits/CircuitUtils.jl#L116-L133",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[123]})])]),_:1,__:[132,133,134,135,136,137,138]}),n(o,{label:"Dynamics"},{default:s(()=>[t[237]||(t[237]=i("h2",{id:"Dynamics",tabindex:"-1"},[l("Dynamics "),i("a",{class:"header-anchor",href:"#Dynamics","aria-label":'Permalink to "Dynamics {#Dynamics}"'},"​")],-1)),i("details",A,[i("summary",null,[t[139]||(t[139]=i("a",{id:"SuperconductingCircuits.Dynamics.calibrate_drive-Tuple{QuantumToolbox.QuantumObjectEvolution, Any, Any, Function}",href:"#SuperconductingCircuits.Dynamics.calibrate_drive-Tuple{QuantumToolbox.QuantumObjectEvolution, Any, Any, Function}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.calibrate_drive")],-1)),t[140]||(t[140]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[142]||(t[142]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"calibrate_drive"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(drive_op"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"qt.QobjEvo"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", t_range0, psi0, to_min"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Function"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"; samples_per_level"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"5"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", maxiters"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"7"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", tol"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"1e-3"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", approx_tol"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"1e-8"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", solver_kwargs"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Dict{Symbol, Any}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(), return_drive"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"true"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", include_H"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"true"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", dt"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"1e-2"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")])])])],-1)),t[143]||(t[143]=i("p",null,"Calibrates the duration of a quantum drive by minimizing a user-specified cost function over a given time range.",-1)),t[144]||(t[144]=i("p",null,[i("strong",null,"Arguments")],-1)),t[145]||(t[145]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"drive_op::qt.QobjEvo"),l(": The time-dependent drive operator (Hamiltonian) to be calibrated.")])]),i("li",null,[i("p",null,[i("code",null,"t_range0"),l(": Initial time range (tuple or array) over which to search for the optimal drive duration.")])]),i("li",null,[i("p",null,[i("code",null,"psi0"),l(": Initial quantum state for the evolution.")])]),i("li",null,[i("p",null,[i("code",null,"to_min::Function"),l(": A function that takes the final state and returns a scalar value to be minimized (e.g., infidelity).")])]),i("li",null,[i("p",null,[i("code",null,"samples_per_level"),l(": Number of time samples to evaluate per iteration (default: 5).")])]),i("li",null,[i("p",null,[i("code",null,"maxiters"),l(": Maximum number of iterations for the calibration loop (default: 7).")])]),i("li",null,[i("p",null,[i("code",null,"tol"),l(": Tolerance for the minimum value of the cost function to consider the calibration successful (default: 1e-3).")])]),i("li",null,[i("p",null,[i("code",null,"approx_tol"),l(": Tolerance for considering two time points as approximately equal (default: 1e-8).")])]),i("li",null,[i("p",null,[i("code",null,"solver_kwargs"),l(": Additional keyword arguments to pass to the ODE solver (default: empty dictionary).")])]),i("li",null,[i("p",null,[i("code",null,"return_drive"),l(": If "),i("code",null,"true"),l(", returns the calibrated drive (currently unused, default: true).")])]),i("li",null,[i("p",null,[i("code",null,"include_H"),l(": If "),i("code",null,"true"),l(", includes the Hamiltonian in the evolution (currently unused, default: true).")])]),i("li",null,[i("p",null,[i("code",null,"dt"),l(": Time step for the evolution solver (default: 1e-2).")])])],-1)),t[146]||(t[146]=i("p",null,[i("strong",null,"Returns")],-1)),t[147]||(t[147]=i("ul",null,[i("li",null,[l("A two-element array "),i("code",null,"[best_time, best_fid]"),l(" where: "),i("ul",null,[i("li",null,[i("p",null,[i("code",null,"best_time"),l(": The optimal drive duration found.")])]),i("li",null,[i("p",null,[i("code",null,"best_fid"),l(": The minimum value of the cost function achieved.")])])])])],-1)),t[148]||(t[148]=i("p",null,[i("strong",null,"Description")],-1)),t[149]||(t[149]=i("p",null,[l("This function iteratively samples the cost function over a shrinking time interval, searching for the drive duration that minimizes the user-provided "),i("code",null,"to_min"),l(" function. The search continues until the minimum value falls below the specified tolerance or the maximum number of iterations is reached.")],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[141]||(t[141]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Dynamics/Drives/DriveCalibration.jl#L1-L27",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[141]})]),i("details",D,[i("summary",null,[t[150]||(t[150]=i("a",{id:"SuperconductingCircuits.Dynamics.find_resonance-Union{Tuple{T1}, Tuple{Any, Any, T1}} where T1<:Dict",href:"#SuperconductingCircuits.Dynamics.find_resonance-Union{Tuple{T1}, Tuple{Any, Any, T1}} where T1<:Dict"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.find_resonance")],-1)),t[151]||(t[151]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[153]||(t[153]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"find_resonance"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(H_func, freqs, reference_states"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"T1"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"; show_plot"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"false"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", plot_freq_offset"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"0"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", plotxlabel"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#032F62","--shiki-dark":"#9ECBFF"}},'"Drive Frequencies (GHz)"'),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},") "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"where"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," T1 "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"<:"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," Dict")])])])],-1)),t[154]||(t[154]=i("p",null,"Finds the resonance frequency and approximate drive time for a driven quantum system using Floquet theory.",-1)),t[155]||(t[155]=i("p",null,[i("strong",null,"Arguments")],-1)),t[156]||(t[156]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"H_func"),l(": A function that generates the system Hamiltonian as a function of parameters.")])]),i("li",null,[i("p",null,[i("code",null,"freqs"),l(": An array of drive frequencies (in GHz) to sweep over.")])]),i("li",null,[i("p",null,[i("code",null,"reference_states::T1"),l(": A dictionary mapping state labels to reference states to track during the Floquet sweep.")])]),i("li",null,[i("p",null,[i("code",null,"show_plot"),l(": (optional) If "),i("code",null,"true"),l(", displays plots of the quasienergies and their differences. Default is "),i("code",null,"false"),l(".")])]),i("li",null,[i("p",null,[i("code",null,"plot_freq_offset"),l(": (optional) Frequency offset to apply to the x-axis of the plots. Default is "),i("code",null,"0"),l(".")])]),i("li",null,[i("p",null,[i("code",null,"plotxlabel"),l(": (optional) Label for the x-axis of the plots. Default is "),i("code",null,'"Drive Frequencies (GHz)"'),l(".")])])],-1)),t[157]||(t[157]=i("p",null,[i("strong",null,"Returns")],-1)),t[158]||(t[158]=i("ul",null,[i("li",null,[l("A two-element array: "),i("ol",null,[i("li",null,[i("p",null,"The resonance frequency (in GHz) where the minimum energy gap occurs.")]),i("li",null,[i("p",null,"The approximate drive time associated with the resonance.")])])])],-1)),t[159]||(t[159]=i("p",null,[i("strong",null,"Description")],-1)),t[160]||(t[160]=i("p",null,"This function performs a sweep over the provided drive frequencies, computes the Floquet quasienergies for the specified reference states, and determines the resonance by fitting the minimum energy gap to a model function. Optionally, it can display plots of the quasienergies and their differences.",-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[152]||(t[152]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Dynamics/Drives/ResonanceFinder.jl#L1-L21",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[152]})]),i("details",T,[i("summary",null,[t[161]||(t[161]=i("a",{id:"SuperconductingCircuits.Dynamics.floquet_sweep-Union{Tuple{T1}, Tuple{Any, Any, Any}} where T1<:Dict",href:"#SuperconductingCircuits.Dynamics.floquet_sweep-Union{Tuple{T1}, Tuple{Any, Any, Any}} where T1<:Dict"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.floquet_sweep")],-1)),t[162]||(t[162]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[164]||(t[164]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"floquet_sweep"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(H_func, sampling_points, T; sampling_times"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"[], use_logging"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"true"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", states_to_track"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Dict{Any, Any}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(), propagator_kwargs"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Dict{Any, Any}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"())")])])])],-1)),t[165]||(t[165]=i("p",null,"Performs a parameter sweep to compute Floquet modes and quasienergies for a family of time-dependent Hamiltonians.",-1)),t[166]||(t[166]=i("p",null,[i("strong",null,"Arguments")],-1)),t[167]||(t[167]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"H_func"),l(": A function that takes a parameter value from "),i("code",null,"sampling_points"),l(" and returns the corresponding Hamiltonian.")])]),i("li",null,[i("p",null,[i("code",null,"sampling_points"),l(": An array of parameter values over which to perform the sweep.")])]),i("li",null,[i("p",null,[i("code",null,"T"),l(": The period of the drive. Can be a scalar (applied to all points) or an array matching "),i("code",null,"sampling_points"),l(".")])]),i("li",null,[i("p",null,[i("code",null,"sampling_times"),l(": (Optional) Array of times at which to evaluate the Floquet modes for each parameter set. Defaults to zeros.")])]),i("li",null,[i("p",null,[i("code",null,"use_logging"),l(": (Optional) If "),i("code",null,"true"),l(", logs progress and status messages.")])]),i("li",null,[i("p",null,[i("code",null,"states_to_track"),l(": (Optional) A dictionary of states to track across the sweep. If provided, state tracking is performed.")])]),i("li",null,[i("p",null,[i("code",null,"propagator_kwargs"),l(": (Optional) Dictionary of keyword arguments to pass to the propagator used in Floquet basis calculation.")])])],-1)),t[168]||(t[168]=i("p",null,[i("strong",null,"Returns")],-1)),t[169]||(t[169]=i("p",null,"A dictionary with the following keys:",-1)),t[170]||(t[170]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,'"F_Modes"'),l(": Array of Floquet modes for each parameter set.")])]),i("li",null,[i("p",null,[i("code",null,'"F_Energies"'),l(": Array of Floquet quasienergies for each parameter set.")])]),i("li",null,[i("p",null,[i("code",null,'"Tracking"'),l(": (Optional) Results from state tracking, if "),i("code",null,"states_to_track"),l(" is provided.")])])],-1)),t[171]||(t[171]=i("p",null,[i("strong",null,"Notes")],-1)),t[172]||(t[172]=i("ul",null,[i("li",null,[i("p",null,[l("If a parameter value in "),i("code",null,"sampling_points"),l(" is repeated, previously computed results are reused.")])]),i("li",null,[i("p",null,"Progress is displayed using a progress bar if logging is enabled.")]),i("li",null,[i("p",null,[l("Requires "),i("code",null,"get_floquet_basis"),l(" and "),i("code",null,"Utils.state_tracker"),l(" to be defined elsewhere.")])])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[163]||(t[163]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Dynamics/Floquet/Floquet_Sweep.jl#L1-L25",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[163]})]),i("details",q,[i("summary",null,[t[173]||(t[173]=i("a",{id:"SuperconductingCircuits.Dynamics.get_FLZ_flattop-Tuple{Any, Any, Any, Any, Function, Any, Any, Any}",href:"#SuperconductingCircuits.Dynamics.get_FLZ_flattop-Tuple{Any, Any, Any, Any, Function, Any, Any, Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.get_FLZ_flattop")],-1)),t[174]||(t[174]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[176]||(t[176]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"get_FLZ_flattop"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(")]),l(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    H_op, drive_op, freq, epsilon, envelope_func, ramp_time, psi0, psi1;")]),l(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"    dt"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"0"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", n_theta_samples"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"100"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", number_eps_samples"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"10")]),l(`
`),i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")])])])],-1)),t[177]||(t[177]=i("p",null,"Determine the optimal flat-top duration for a Floquet-Landau-Zener (FLZ) protocol in a driven quantum system.",-1)),t[178]||(t[178]=i("p",null,[i("strong",null,"Arguments")],-1)),t[179]||(t[179]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"H_op"),l(": Static system Hamiltonian.")])]),i("li",null,[i("p",null,[i("code",null,"drive_op"),l(": Operator representing the drive interaction.")])]),i("li",null,[i("p",null,[i("code",null,"freq"),l(": Drive frequency (Hz).")])]),i("li",null,[i("p",null,[i("code",null,"epsilon"),l(": Drive amplitude.")])]),i("li",null,[i("p",null,[i("code",null,"envelope_func::Function"),l(": Time-dependent envelope function for the drive pulse.")])]),i("li",null,[i("p",null,[i("code",null,"ramp_time"),l(": Duration of the ramp segment (same time units as used elsewhere).")])]),i("li",null,[i("p",null,[i("code",null,"psi0"),l(": Initial quantum state (e.g., ground state).")])]),i("li",null,[i("p",null,[i("code",null,"psi1"),l(": Target quantum state (e.g., excited state).")])])],-1)),t[180]||(t[180]=i("p",null,[i("strong",null,"Keyword Arguments")],-1)),t[181]||(t[181]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"dt"),l(": Time step for numerical evolution. Defaults to "),i("code",null,"1/freq"),l(" if set to 0.")])]),i("li",null,[i("p",null,[i("code",null,"n_theta_samples"),l(": Number of phase grid points for optimization (default: 100).")])]),i("li",null,[i("p",null,[i("code",null,"num_t_samples"),l(": Number of time samples to evaluate the floquet modes (default: 10).")])]),i("li",null,[i("p",null,[i("code",null,"epsilons_to_sample"),l(": Optional array of epsilon values to sample at each time step. If not provided, it is computed based on the envelope function.")])])],-1)),t[182]||(t[182]=i("p",null,[i("strong",null,"Returns")],-1)),t[183]||(t[183]=i("ul",null,[i("li",null,[l("The calibrated flat-top duration (same units as "),i("code",null,"ramp_time"),l(") that aligns the system's evolution with the desired Floquet phase, facilitating high-fidelity state transfer.")])],-1)),t[184]||(t[184]=i("p",null,[i("strong",null,"Details")],-1)),t[185]||(t[185]=i("p",null,"This function simulates the system's evolution under a driven protocol, performing a Floquet analysis to optimize the phase accumulation. It searches for the flat-top time that best matches the target state, using grid search over phase and amplitude parameters. Diagnostic information about the Floquet frequency and phase is printed during execution.",-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[175]||(t[175]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Dynamics/Drives/DriveCalibration.jl#L78-L107",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[175]})]),i("details",S,[i("summary",null,[t[186]||(t[186]=i("a",{id:"SuperconductingCircuits.Dynamics.get_floquet_basis-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}",href:"#SuperconductingCircuits.Dynamics.get_floquet_basis-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.get_floquet_basis")],-1)),t[187]||(t[187]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[189]||(t[189]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"get_floquet_basis"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(H"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Union{qt.QuantumObject, qt.QobjEvo}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", T; t0 "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," 0"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", propagator_kwargs "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," Dict{Symbol, Any}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"())")])])])],-1)),t[190]||(t[190]=i("p",null,"Compute the Floquet basis for a time-periodic Hamiltonian.",-1)),t[191]||(t[191]=i("p",null,[i("strong",null,"Arguments")],-1)),t[192]||(t[192]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"H::Union{qt.QuantumObject, qt.QobjEvo}"),l(": The time-dependent Hamiltonian, either as a quantum object or a time-evolution operator.")])]),i("li",null,[i("p",null,[i("code",null,"T"),l(": The period of the Hamiltonian.")])]),i("li",null,[i("p",null,[i("code",null,"t0"),l(": (optional) Initial time. Defaults to "),i("code",null,"0"),l(".")])]),i("li",null,[i("p",null,[i("code",null,"propagator_kwargs"),l(": (optional) Dictionary of keyword arguments to pass to the propagator functions.")])])],-1)),t[193]||(t[193]=i("p",null,[i("strong",null,"Returns")],-1)),t[194]||(t[194]=i("ul",null,[i("li",null,"A tuple containing the Floquet quasi-energies and a function that returns the time-evolved Floquet modes at any given time.")],-1)),t[195]||(t[195]=i("p",null,[i("strong",null,"Description")],-1)),t[196]||(t[196]=i("p",null,"This function computes the Floquet basis by:",-1)),t[197]||(t[197]=i("ol",null,[i("li",null,[i("p",null,"Calculating the propagator over one period.")]),i("li",null,[i("p",null,"Diagonalizing the propagator to obtain Floquet quasi-energies and modes.")]),i("li",null,[i("p",null,"Returning the quasi-energies and a function for propagating the Floquet modes in time.")])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[188]||(t[188]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Dynamics/Floquet/Floquet_Basis.jl#L1-L20",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[188]})]),i("details",x,[i("summary",null,[t[198]||(t[198]=i("a",{id:"SuperconductingCircuits.Dynamics.get_propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}}",href:"#SuperconductingCircuits.Dynamics.get_propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.get_propagator")],-1)),t[199]||(t[199]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[201]||(t[201]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"get_propagator"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(H"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Union{qt.QobjEvo, qt.QuantumObject}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")])])])],-1)),t[202]||(t[202]=i("p",null,[l("Constructs a "),i("code",null,"Propagator"),l(" object for the given Hamiltonian "),i("code",null,"H"),l(", which can be either a "),i("code",null,"qt.QobjEvo"),l(" or a "),i("code",null,"qt.QuantumObject"),l(".")],-1)),t[203]||(t[203]=i("p",null,[l("The returned "),i("code",null,"Propagator"),l(" provides a function interface to compute the time-evolution operator for "),i("code",null,"H"),l(" over a specified time interval. The function accepts the final time "),i("code",null,"tf"),l(", an optional initial time "),i("code",null,"ti"),l(" (default is 0), and an optional dictionary of solver keyword arguments "),i("code",null,"solver_kwargs"),l(".")],-1)),t[204]||(t[204]=i("p",null,[i("strong",null,"Arguments")],-1)),t[205]||(t[205]=i("ul",null,[i("li",null,[i("code",null,"H::Union{qt.QobjEvo, qt.QuantumObject}"),l(": The Hamiltonian for which the propagator is constructed.")])],-1)),t[206]||(t[206]=i("p",null,[i("strong",null,"Returns")],-1)),t[207]||(t[207]=i("ul",null,[i("li",null,[i("code",null,"Propagator"),l(": An object that can be called to compute the propagator for the specified time interval and solver options.")])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[200]||(t[200]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Dynamics/Utils/Propagator.jl#L57-L69",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[200]})]),i("details",w,[i("summary",null,[t[208]||(t[208]=i("a",{id:"SuperconductingCircuits.Dynamics.propagate_floquet_modes-NTuple{4, Any}",href:"#SuperconductingCircuits.Dynamics.propagate_floquet_modes-NTuple{4, Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.propagate_floquet_modes")],-1)),t[209]||(t[209]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[211]||(t[211]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"propagate_floquet_modes"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(modes_t0, U, t, T; propagator_kwargs"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Dict{Symbol, Any}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"())")])])])],-1)),t[212]||(t[212]=i("p",null,[l("Propagates a set of Floquet modes from the initial time "),i("code",null,"t₀"),l(" to a later time "),i("code",null,"t"),l(" using the provided propagator "),i("code",null,"U"),l(".")],-1)),t[213]||(t[213]=i("p",null,[i("strong",null,"Arguments")],-1)),t[214]||(t[214]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"modes_t0"),l(": Array of Floquet modes at the initial time "),i("code",null,"t₀"),l(".")])]),i("li",null,[i("p",null,[i("code",null,"U"),l(": A propagator object with an "),i("code",null,"eval"),l(" method, used to compute the time evolution operator.")])]),i("li",null,[i("p",null,[i("code",null,"t"),l(": The target time to which the modes should be propagated.")])]),i("li",null,[i("p",null,[i("code",null,"T"),l(": The period of the Floquet system.")])]),i("li",null,[i("p",null,[i("code",null,"propagator_kwargs"),l(": (Optional) Dictionary of keyword arguments to pass to the propagator's "),i("code",null,"eval"),l(" method.")])])],-1)),t[215]||(t[215]=i("p",null,[i("strong",null,"Returns")],-1)),t[216]||(t[216]=i("ul",null,[i("li",null,[l("An array of Floquet modes at time "),i("code",null,"t"),l(".")])],-1)),t[217]||(t[217]=i("p",null,[i("strong",null,"Notes")],-1)),t[218]||(t[218]=i("ul",null,[i("li",null,[i("p",null,[l("If "),i("code",null,"t"),l(" is an integer multiple of "),i("code",null,"T"),l(", the function returns the initial modes unchanged.")])]),i("li",null,[i("p",null,[l("Otherwise, the function computes the propagator for the time offset "),i("code",null,"t % T"),l(" and applies it to each mode.")])])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[210]||(t[210]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Dynamics/Floquet/Floquet_Utils.jl#L1-L19",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[210]})]),i("details",O,[i("summary",null,[t[219]||(t[219]=i("a",{id:"SuperconductingCircuits.Dynamics.propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}",href:"#SuperconductingCircuits.Dynamics.propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.propagator")],-1)),t[220]||(t[220]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[222]||(t[222]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"propagator"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(H"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Union{qt.QobjEvo, qt.QuantumObject}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", tf; ti "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," 0"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", solver "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," DE"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"."),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Vern9"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(), solver_kwargs "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}}," Dict{Any, Any}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"())")])])])],-1)),t[223]||(t[223]=i("p",null,[l("Compute the time-evolution operator (propagator) for a given time-dependent or time-independent Hamiltonian "),i("code",null,"H"),l(" from initial time "),i("code",null,"ti"),l(" to final time "),i("code",null,"tf"),l(".")],-1)),t[224]||(t[224]=i("p",null,[i("strong",null,"Arguments")],-1)),t[225]||(t[225]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"H::Union{qt.QobjEvo, qt.QuantumObject}"),l(": The Hamiltonian, either as a time-dependent ("),i("code",null,"qt.QobjEvo"),l(") or time-independent ("),i("code",null,"qt.QuantumObject"),l(") quantum object.")])]),i("li",null,[i("p",null,[i("code",null,"tf"),l(": The final time for propagation.")])]),i("li",null,[i("p",null,[i("code",null,"ti"),l(": (optional) The initial time. Defaults to "),i("code",null,"0"),l(".")])]),i("li",null,[i("p",null,[i("code",null,"solver"),l(": (optional) The ODE solver to use from DifferentialEquations.jl. Defaults to "),i("code",null,"DE.Vern9()"),l(".")])]),i("li",null,[i("p",null,[i("code",null,"solver_kwargs"),l(": (optional) Additional keyword arguments to pass to the ODE solver.")])])],-1)),t[226]||(t[226]=i("p",null,[i("strong",null,"Returns")],-1)),t[227]||(t[227]=i("ul",null,[i("li",null,[i("code",null,"qt.Qobj"),l(": The propagator (time-evolution operator) as a quantum object, mapping the system from time "),i("code",null,"ti"),l(" to "),i("code",null,"tf"),l(".")])],-1)),t[228]||(t[228]=i("p",null,[i("strong",null,"Notes")],-1)),t[229]||(t[229]=i("ul",null,[i("li",null,[i("p",null,"The function internally constructs the ODE for the propagator in the Schrödinger picture and solves it using the specified solver.")]),i("li",null,[i("p",null,"If the Hamiltonian is sparse, the propagator is returned as a sparse matrix.")])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[221]||(t[221]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Dynamics/Utils/Propagator.jl#L18-L36",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[221]})]),i("details",B,[i("summary",null,[t[230]||(t[230]=i("a",{id:"SuperconductingCircuits.Dynamics.Propagator",href:"#SuperconductingCircuits.Dynamics.Propagator"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.Propagator")],-1)),t[231]||(t[231]=l()),n(e,{type:"info",class:"jlObjectType jlType",text:"Type"})]),t[233]||(t[233]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"Propagator")])])])],-1)),t[234]||(t[234]=i("p",null,"A structure representing a quantum propagator for time evolution.",-1)),t[235]||(t[235]=i("p",null,[i("strong",null,"Fields")],-1)),t[236]||(t[236]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"H::Union{qt.QobjEvo, qt.QuantumObject}"),l(": The Hamiltonian or time-dependent operator governing the system's dynamics. This can be a "),i("code",null,"qt.QobjEvo"),l(" for time-dependent Hamiltonians or a "),i("code",null,"qt.QuantumObject"),l(" for time-independent cases.")])]),i("li",null,[i("p",null,[i("code",null,"eval::Function"),l(": A function that computes the propagator or evolves the quantum state, typically as a function of time and initial state.")])])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[232]||(t[232]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Dynamics/Utils/Propagator.jl#L3-L11",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[232]})])]),_:1,__:[237]}),n(o,{label:"Utils"},{default:s(()=>[t[276]||(t[276]=i("h2",{id:"Utils-2",tabindex:"-1"},[l("Utils "),i("a",{class:"header-anchor",href:"#Utils-2","aria-label":'Permalink to "Utils {#Utils-2}"'},"​")],-1)),i("details",H,[i("summary",null,[t[238]||(t[238]=i("a",{id:"SuperconductingCircuits.Utils.identity_wrapper-Tuple{Dict, Any}",href:"#SuperconductingCircuits.Utils.identity_wrapper-Tuple{Dict, Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Utils.identity_wrapper")],-1)),t[239]||(t[239]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[241]||(t[241]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"identity_wrapper"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(𝕀̂_Dict"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Dict"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", Operator_Dict; order "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," [])")])])])],-1)),t[242]||(t[242]=i("p",null,[l("Constructs a tensor product of operators, replacing identity operators with those specified in "),i("code",null,"Operator_Dict"),l(".")],-1)),t[243]||(t[243]=i("p",null,[i("strong",null,"Arguments")],-1)),t[244]||(t[244]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"𝕀̂_Dict::Dict"),l(": A dictionary mapping subsystem keys to identity operators.")])]),i("li",null,[i("p",null,[i("code",null,"Operator_Dict::Dict"),l(": A dictionary mapping subsystem keys to operators that should replace the corresponding identities.")])]),i("li",null,[i("p",null,[i("code",null,"order::Vector"),l(" (optional): An array specifying the order of subsystems in the tensor product. If not provided, the order of keys in "),i("code",null,"𝕀̂_Dict"),l(" is used.")])])],-1)),t[245]||(t[245]=i("p",null,[i("strong",null,"Returns")],-1)),t[246]||(t[246]=i("ul",null,[i("li",null,[l("The tensor product (using "),i("code",null,"qt.tensor"),l(") of the operators, with identities replaced as specified.")])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[240]||(t[240]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Utils/IdentityWrappers.jl#L1-L13",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[240]})]),i("details",Q,[i("summary",null,[t[247]||(t[247]=i("a",{id:"SuperconductingCircuits.Utils.parse_and_eval-Tuple{Any, Any}",href:"#SuperconductingCircuits.Utils.parse_and_eval-Tuple{Any, Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Utils.parse_and_eval")],-1)),t[248]||(t[248]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[250]||(t[250]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"parse_and_eval"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(expr"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"AbstractString"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", x)")])])])],-1)),t[251]||(t[251]=i("p",null,[l("Parses the string "),i("code",null,"expr"),l(" as a Julia expression, defines a function "),i("code",null,"eval_func(x)"),l(" that evaluates this expression with the given argument "),i("code",null,"x"),l(", and then invokes this function using "),i("code",null,"invokelatest"),l(".")],-1)),t[252]||(t[252]=i("p",null,[i("strong",null,"Arguments")],-1)),t[253]||(t[253]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"expr::AbstractString"),l(": A string representing a Julia expression, which should be valid code involving the variable "),i("code",null,"x"),l(".")])]),i("li",null,[i("p",null,[i("code",null,"x"),l(": The value to substitute for "),i("code",null,"x"),l(" in the evaluated expression.")])])],-1)),t[254]||(t[254]=i("p",null,[i("strong",null,"Returns")],-1)),t[255]||(t[255]=i("ul",null,[i("li",null,[l("The result of evaluating the parsed expression with the provided value of "),i("code",null,"x"),l(".")])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[249]||(t[249]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Utils/RandomThings.jl#L18-L29",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[249]})]),i("details",R,[i("summary",null,[t[256]||(t[256]=i("a",{id:"SuperconductingCircuits.Utils.state_tracker-Tuple{Vector, Dict}",href:"#SuperconductingCircuits.Utils.state_tracker-Tuple{Vector, Dict}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Utils.state_tracker")],-1)),t[257]||(t[257]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[259]||(t[259]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"state_tracker"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(state_history"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Vector"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},", states_to_track"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"::"),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Dict"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"; other_sorts"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"Dict{Any, Any}"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(), use_logging"),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"="),i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"true"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},")")])])])],-1)),t[260]||(t[260]=i("p",null,"Tracks the evolution of specified quantum states across a sequence of state histories.",-1)),t[261]||(t[261]=i("p",null,[i("strong",null,"Arguments")],-1)),t[262]||(t[262]=i("ul",null,[i("li",null,[i("p",null,[i("code",null,"state_history::Vector"),l(": A vector where each element is a collection (e.g., vector or array) of quantum states at a given time step.")])]),i("li",null,[i("p",null,[i("code",null,"states_to_track::Dict"),l(": A dictionary mapping state identifiers to their initial state vectors to be tracked.")])]),i("li",null,[i("p",null,[i("code",null,"other_sorts::Dict{Any, Any}"),l(" (optional): A dictionary mapping additional property names to arrays of properties, which are also tracked for each state and time step. Defaults to an empty dictionary.")])]),i("li",null,[i("p",null,[i("code",null,"use_logging::Bool"),l(" (optional): If "),i("code",null,"true"),l(", enables debug and info logging for tracking progress and overlaps. Defaults to "),i("code",null,"true"),l(".")])])],-1)),t[263]||(t[263]=i("p",null,[i("strong",null,"Returns")],-1)),t[264]||(t[264]=i("ul",null,[i("li",null,[i("code",null,"history"),l(": A multidimensional array (AxisArray or similar) indexed by state and step, where each entry is a dictionary containing: "),i("ul",null,[i("li",null,[i("p",null,[i("code",null,'"psi"'),l(": The tracked state vector at that step.")])]),i("li",null,[i("p",null,[i("code",null,'"overlap"'),l(": The maximum overlap value found for the state at that step.")])]),i("li",null,[i("p",null,[l("Additional keys for each property in "),i("code",null,"other_sorts"),l(", containing their respective values.")])])])])],-1)),t[265]||(t[265]=i("p",null,[i("strong",null,"Description")],-1)),t[266]||(t[266]=i("p",null,[l("For each state specified in "),i("code",null,"states_to_track"),l(", the function iteratively finds, at each time step, the state in "),i("code",null,"state_history"),l(" with the maximum overlap (squared inner product) with the previous step's tracked state. It records the state vector, overlap, and any additional properties provided in "),i("code",null,"other_sorts"),l(". The function also ensures that the same state is not assigned to multiple tracked states at the same step, logging a warning if this occurs.")],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[258]||(t[258]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Utils/StateTracking.jl#L1-L20",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[258]})]),i("details",L,[i("summary",null,[t[267]||(t[267]=i("a",{id:"SuperconductingCircuits.Utils.tostr-Tuple{Any}",href:"#SuperconductingCircuits.Utils.tostr-Tuple{Any}"},[i("span",{class:"jlbinding"},"SuperconductingCircuits.Utils.tostr")],-1)),t[268]||(t[268]=l()),n(e,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),t[270]||(t[270]=i("div",{class:"language-julia vp-adaptive-theme"},[i("button",{title:"Copy Code",class:"copy"}),i("span",{class:"lang"},"julia"),i("pre",{class:"shiki shiki-themes github-light github-dark vp-code",tabindex:"0"},[i("code",null,[i("span",{class:"line"},[i("span",{style:{"--shiki-light":"#005CC5","--shiki-dark":"#79B8FF"}},"tostr"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}},"(obj) "),i("span",{style:{"--shiki-light":"#D73A49","--shiki-dark":"#F97583"}},"->"),i("span",{style:{"--shiki-light":"#24292E","--shiki-dark":"#E1E4E8"}}," String")])])])],-1)),t[271]||(t[271]=i("p",null,[l("Converts the given object "),i("code",null,"obj"),l(" to its plain text string representation by using the "),i("code",null,"show"),l(" function with the "),i("code",null,'"text/plain"'),l(" MIME type.")],-1)),t[272]||(t[272]=i("p",null,[i("strong",null,"Arguments")],-1)),t[273]||(t[273]=i("ul",null,[i("li",null,[i("code",null,"obj"),l(": Any Julia object to be converted to a string.")])],-1)),t[274]||(t[274]=i("p",null,[i("strong",null,"Returns")],-1)),t[275]||(t[275]=i("ul",null,[i("li",null,[i("code",null,"String"),l(": The plain text representation of "),i("code",null,"obj"),l(".")])],-1)),n(e,{type:"info",class:"source-link",text:"source"},{default:s(()=>t[269]||(t[269]=[i("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/d43eb5a96fa269b4a8b2f3f56737a6a237cf6d65/src/Utils/RandomThings.jl#L1-L11",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[269]})])]),_:1,__:[276]})]),_:1})])}const J=u(g,[["render",U]]);export{z as __pageData,J as default};
