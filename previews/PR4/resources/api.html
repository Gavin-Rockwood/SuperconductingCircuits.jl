<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>SuperconductingCircuits.jl Documentation | SuperconductingCircuits.jl</title>
    <meta name="description" content="Documentation for SuperconductingCircuits.jl">
    <meta name="generator" content="VitePress v1.6.3">
    <link rel="preload stylesheet" href="/SuperconductingCircuits.jl/previews/PR4/assets/style.BrRw1tsB.css" as="style">
    <link rel="preload stylesheet" href="/SuperconductingCircuits.jl/previews/PR4/vp-icons.css" as="style">
    
    <script type="module" src="/SuperconductingCircuits.jl/previews/PR4/assets/app.DWoY-glb.js"></script>
    <link rel="preload" href="/SuperconductingCircuits.jl/previews/PR4/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/SuperconductingCircuits.jl/previews/PR4/assets/chunks/theme.DiVXGW3Y.js">
    <link rel="modulepreload" href="/SuperconductingCircuits.jl/previews/PR4/assets/chunks/framework.4g_dWvaV.js">
    <link rel="modulepreload" href="/SuperconductingCircuits.jl/previews/PR4/assets/resources_api.md.CgC0m9Ul.lean.js">
    <link rel="icon" href="/SuperconductingCircuits.jl/favicon.ico">
    <script src="/SuperconductingCircuits.jl/versions.js"></script>
    <script src="/SuperconductingCircuits.jl/previews/PR4/siteinfo.js"></script>
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-a9a9e638><!--[--><!--]--><!--[--><span tabindex="-1" data-v-492508fc></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-492508fc>Skip to content</a><!--]--><!----><header class="VPNav" data-v-a9a9e638 data-v-f1e365da><div class="VPNavBar" data-v-f1e365da data-v-822684d1><div class="wrapper" data-v-822684d1><div class="container" data-v-822684d1><div class="title" data-v-822684d1><div class="VPNavBarTitle has-sidebar" data-v-822684d1 data-v-0f4f798b><a class="title" href="/SuperconductingCircuits.jl/previews/PR4/" data-v-0f4f798b><!--[--><!--]--><!----><span data-v-0f4f798b>SuperconductingCircuits.jl</span><!--[--><!--]--></a></div></div><div class="content" data-v-822684d1><div class="content-body" data-v-822684d1><!--[--><!--]--><div class="VPNavBarSearch search" data-v-822684d1><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-822684d1 data-v-e6d46098><span id="main-nav-aria-label" class="visually-hidden" data-v-e6d46098> Main Navigation </span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/SuperconductingCircuits.jl/previews/PR4/index" tabindex="0" data-v-e6d46098 data-v-956ec74c><!--[--><span data-v-956ec74c>Home</span><!--]--></a><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Getting Started</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link" href="/SuperconductingCircuits.jl/previews/PR4/getting_started/overview" data-v-acbfed09><!--[--><span data-v-acbfed09>Overview</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>User Guide</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>Circuits</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/SuperconductingCircuits.jl/previews/PR4/user_guide/circuits/circuit_elements/circuit_elements" data-v-acbfed09><!--[--><span data-v-acbfed09>Circuit Elements</span><!--]--></a></div><!--]--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/SuperconductingCircuits.jl/previews/PR4/user_guide/circuits/building_circuits/building_circuits" data-v-acbfed09><!--[--><span data-v-acbfed09>Building Circuits</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--[--><div class="VPMenuGroup" data-v-7dd3104a data-v-48c802d0><p class="title" data-v-48c802d0>Dynamics</p><!--[--><!--[--><div class="VPMenuLink" data-v-48c802d0 data-v-acbfed09><a class="VPLink link" href="/SuperconductingCircuits.jl/previews/PR4/user_guide/dynamics/floquet/floquet" data-v-acbfed09><!--[--><span data-v-acbfed09>Floquet Tools</span><!--]--></a></div><!--]--><!--]--></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><div class="VPFlyout VPNavBarMenuGroup active" data-v-e6d46098 data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><!----><span data-v-04f5c5e9>Resources</span><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><div class="items" data-v-7dd3104a><!--[--><!--[--><div class="VPMenuLink" data-v-7dd3104a data-v-acbfed09><a class="VPLink link active" href="/SuperconductingCircuits.jl/previews/PR4/resources/api" data-v-acbfed09><!--[--><span data-v-acbfed09>API</span><!--]--></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--[--><!----><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-822684d1 data-v-af096f4a><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-af096f4a data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-822684d1 data-v-164c457f data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-github"></span></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-822684d1 data-v-925effce data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-04f5c5e9><span class="vpi-more-horizontal icon" data-v-04f5c5e9></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--[--><!----><div class="group" data-v-925effce><div class="item appearance" data-v-925effce><p class="label" data-v-925effce>Appearance</p><div class="appearance-action" data-v-925effce><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-925effce data-v-e40a8bb6 data-v-4a1c76db><span class="check" data-v-4a1c76db><span class="icon" data-v-4a1c76db><!--[--><span class="vpi-sun sun" data-v-e40a8bb6></span><span class="vpi-moon moon" data-v-e40a8bb6></span><!--]--></span></span></button></div></div></div><div class="group" data-v-925effce><div class="item social-links" data-v-925effce><div class="VPSocialLinks social-links-list" data-v-925effce data-v-ee7a9424><!--[--><a class="VPSocialLink no-icon" href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl" aria-label="github" target="_blank" rel="noopener" data-v-ee7a9424 data-v-d26d30cb><span class="vpi-social-github"></span></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--[--><!--[--><div class="VPFlyout VPNolebaseEnhancedReadabilitiesMenu VPNolebaseEnhancedReadabilitiesMenuFlyout" aria-label="Enhanced Readability" role="menuitem" data-v-04f5c5e9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-04f5c5e9><span class="text" data-v-04f5c5e9><span class="i-icon-park-outline:book-open option-icon" data-v-04f5c5e9></span><!----><span class="vpi-chevron-down text-icon" data-v-04f5c5e9></span></span></button><div class="menu" data-v-04f5c5e9><div class="VPMenu" data-v-04f5c5e9 data-v-7dd3104a><!----><!--[--><!--]--></div></div></div><!--]--><!--]--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-822684d1 data-v-5dea55bf><span class="container" data-v-5dea55bf><span class="top" data-v-5dea55bf></span><span class="middle" data-v-5dea55bf></span><span class="bottom" data-v-5dea55bf></span></span></button></div></div></div></div><div class="divider" data-v-822684d1><div class="divider-line" data-v-822684d1></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-a9a9e638 data-v-070ab83d><div class="container" data-v-070ab83d><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-070ab83d><span class="vpi-align-left menu-icon" data-v-070ab83d></span><span class="menu-text" data-v-070ab83d>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-070ab83d data-v-168ddf5d><button data-v-168ddf5d>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-a9a9e638 data-v-18756405><div class="curtain" data-v-18756405></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-18756405><span class="visually-hidden" id="sidebar-aria-label" data-v-18756405> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0" data-v-9e426adc data-v-a4b0d9bf><!----><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/SuperconductingCircuits.jl/previews/PR4/index" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Home</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0 collapsible" data-v-9e426adc data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h2 class="text" data-v-a4b0d9bf>Getting Started</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/SuperconductingCircuits.jl/previews/PR4/getting_started/overview" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Overview</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0 collapsible" data-v-9e426adc data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h2 class="text" data-v-a4b0d9bf>User Guide</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><section class="VPSidebarItem level-1 collapsible" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h3 class="text" data-v-a4b0d9bf>Circuits</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/SuperconductingCircuits.jl/previews/PR4/user_guide/circuits/circuit_elements/circuit_elements" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Circuit Elements</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/SuperconductingCircuits.jl/previews/PR4/user_guide/circuits/building_circuits/building_circuits" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Building Circuits</p><!--]--></a><!----></div><!----></div><!--]--></div></section><section class="VPSidebarItem level-1 collapsible" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h3 class="text" data-v-a4b0d9bf>Dynamics</h3><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-2 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/SuperconductingCircuits.jl/previews/PR4/user_guide/dynamics/floquet/floquet" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>Floquet Tools</p><!--]--></a><!----></div><!----></div><!--]--></div></section><!--]--></div></section></div><div class="no-transition group" data-v-9e426adc><section class="VPSidebarItem level-0 collapsible has-active" data-v-9e426adc data-v-a4b0d9bf><div class="item" role="button" tabindex="0" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><h2 class="text" data-v-a4b0d9bf>Resources</h2><div class="caret" role="button" aria-label="toggle section" tabindex="0" data-v-a4b0d9bf><span class="vpi-chevron-right caret-icon" data-v-a4b0d9bf></span></div></div><div class="items" data-v-a4b0d9bf><!--[--><div class="VPSidebarItem level-1 is-link" data-v-a4b0d9bf data-v-a4b0d9bf><div class="item" data-v-a4b0d9bf><div class="indicator" data-v-a4b0d9bf></div><a class="VPLink link link" href="/SuperconductingCircuits.jl/previews/PR4/resources/api" data-v-a4b0d9bf><!--[--><p class="text" data-v-a4b0d9bf>API</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-a9a9e638 data-v-91765379><div class="VPDoc has-sidebar has-aside" data-v-91765379 data-v-83890dd9><!--[--><!--]--><div class="container" data-v-83890dd9><div class="aside" data-v-83890dd9><div class="aside-curtain" data-v-83890dd9></div><div class="aside-container" data-v-83890dd9><div class="aside-content" data-v-83890dd9><div class="VPDocAside" data-v-83890dd9 data-v-6d7b3c46><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-6d7b3c46 data-v-b38bf2ff><div class="content" data-v-b38bf2ff><div class="outline-marker" data-v-b38bf2ff></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-b38bf2ff>On this page</div><ul class="VPDocOutlineItem root" data-v-b38bf2ff data-v-3f927ebe><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-6d7b3c46></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-83890dd9><div class="content-container" data-v-83890dd9><!--[--><!--]--><main class="main" data-v-83890dd9><div style="position:relative;" class="vp-doc _SuperconductingCircuits_jl_previews_PR4_resources_api" data-v-83890dd9><div><h1 id="SuperconductingCircuits.jl-Documentation" tabindex="-1">SuperconductingCircuits.jl Documentation <a class="header-anchor" href="#SuperconductingCircuits.jl-Documentation" aria-label="Permalink to &quot;SuperconductingCircuits.jl Documentation {#SuperconductingCircuits.jl-Documentation}&quot;">​</a></h1><h2 id="Circuits" tabindex="-1">Circuits <a class="header-anchor" href="#Circuits" aria-label="Permalink to &quot;Circuits {#Circuits}&quot;">​</a></h2><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Circuits.init_circuit-Tuple{AbstractArray{CircuitComponent}, Any}" href="#SuperconductingCircuits.Circuits.init_circuit-Tuple{AbstractArray{CircuitComponent}, Any}"><span class="jlbinding">SuperconductingCircuits.Circuits.init_circuit</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">init_circuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(components</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{Component}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, interactions; operators_to_add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{String, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), use_sparse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dressed_kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Initialize a quantum circuit from a list of components and their interactions.</p><p><strong>Arguments</strong></p><ul><li><p><code>components::AbstractArray{Component}</code>: An array of <code>Component</code> objects representing the subsystems of the circuit.</p></li><li><p><code>interactions</code>: A collection describing the interactions between components. Each interaction is typically a tuple or array where the first element is the coupling strength and the remaining elements specify the operators for each component.</p></li><li><p><code>operators_to_add=Dict{String, Any}()</code>: (Optional) A dictionary of additional operators to add to the circuit, keyed by operator name.</p></li><li><p><code>use_sparse=true</code>: (Optional) If <code>true</code>, use sparse matrix representations for operators and Hamiltonians.</p></li><li><p><code>dressed_kwargs=Dict{Symbol, Any}()</code>: (Optional) Keyword arguments passed to the dressed state calculation, such as <code>:f</code> (function for transformation) and <code>:step_number</code> (number of steps).</p></li></ul><p><strong>Returns</strong></p><ul><li><code>circuit::Circuit</code>: An initialized <code>Circuit</code> object containing the Hamiltonian, dressed states and energies, loss operators, component dictionary, and other relevant circuit information.</li></ul><p><strong>Details</strong></p><ul><li><p>Constructs the total Hilbert space dimensions and identity operators for each component.</p></li><li><p>Builds the bare Hamiltonian (<code>H_op_0</code>) and adds interaction terms to form the full Hamiltonian (<code>H_op</code>).</p></li><li><p>Calculates dressed states and energies using <code>get_dressed_states</code>.</p></li><li><p>Assembles loss operators for each component.</p></li><li><p>Organizes components and other circuit data into a <code>Circuit</code> struct.</p></li><li><p>Optionally adds user-specified operators to the circuit.</p></li></ul><hr><hr><p><strong>Overloaded As:</strong></p><hr><p><strong>init_circuit(components::AbstractArray{Dict}, types, interactions; kwargs...)</strong></p><p>Instead of taking in a list of initialized circuit elements, this takes in a list of parameter dictionaries and a list of of the corresponding circuit element types instead.</p><p><strong>Arguments</strong></p><ul><li><p><code>components::AbstractArray{Dict}</code>: An array of dictionaries, each containing the parameters for a circuit component.</p></li><li><p><code>types</code>: An array specifying the type of each component, used to select the appropriate constructor from <code>Component_inits</code>.</p></li><li><p><code>interactions</code>: Data structure describing the interactions between components.</p></li><li><p><code>kwargs...</code>: Additional keyword arguments passed to the underlying <code>init_circuit</code> method.</p></li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Circuits/CircuitConstructor.jl#L1-L36" target="_blank" rel="noreferrer">source</a><!--]--></span></details><h3 id="Components" tabindex="-1">Components <a class="header-anchor" href="#Components" aria-label="Permalink to &quot;Components {#Components}&quot;">​</a></h3><h4 id="Qubit" tabindex="-1">Qubit <a class="header-anchor" href="#Qubit" aria-label="Permalink to &quot;Qubit {#Qubit}&quot;">​</a></h4><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Circuits.Qubit" href="#SuperconductingCircuits.Circuits.Qubit"><span class="jlbinding">SuperconductingCircuits.Circuits.Qubit</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Qubit</span></span></code></pre></div><p>A structure representing a quantum bit (qubit) component in a superconducting circuit.</p><p><strong>Fields</strong></p><ul><li><p><code>dim::Int</code>: The Hilbert space dimension of the qubit (Always 2).</p></li><li><p><code>params::Dict</code>: Dictionary containing the physical parameters of the qubit.</p></li><li><p><code>H_op::qt.QuantumObject</code>: The Hamiltonian operator of the qubit, represented as a quantum object.</p></li><li><p><code>eigenstates::Vector</code>: Vector containing the eigenstates of the qubit Hamiltonian.</p></li><li><p><code>eigenenergies::Vector</code>: Vector containing the eigenenergies corresponding to the eigenstates.</p></li><li><p><code>loss_ops::Dict</code>: Dictionary of loss (dissipation) operators associated with the qubit.</p></li><li><p><code>freq::Float64</code>: The transition frequency of the qubit.</p></li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Circuits/Components/Qubit.jl#L1-L14" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Circuits.init_qubit-Tuple{Any}" href="#SuperconductingCircuits.Circuits.init_qubit-Tuple{Any}"><span class="jlbinding">SuperconductingCircuits.Circuits.init_qubit</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">init_qubit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(freq; name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Qubit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Initialize a <code>Qubit</code> object with the specified transition frequency <code>freq</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>freq::Number</code>: The transition frequency of the qubit.</p></li><li><p><code>name::String</code> (optional): The name of the qubit. Defaults to <code>&quot;Qubit&quot;</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Qubit</code>: An initialized <code>Qubit</code> object containing the Hamiltonian operator, eigenenergies, eigenstates, and other parameters.</li></ul><p><strong>Details</strong></p><p>The function constructs the qubit Hamiltonian as <code>H_op = freq * qt.sigmaz() / 2</code>, computes its eigenenergies and eigenstates, and returns a <code>Qubit</code> object with these properties.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Circuits/Components/Qubit.jl#L33-L47" target="_blank" rel="noreferrer">source</a><!--]--></span></details><h4 id="Resonator" tabindex="-1">Resonator <a class="header-anchor" href="#Resonator" aria-label="Permalink to &quot;Resonator {#Resonator}&quot;">​</a></h4><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Circuits.Resonator" href="#SuperconductingCircuits.Circuits.Resonator"><span class="jlbinding">SuperconductingCircuits.Circuits.Resonator</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Resonator</span></span></code></pre></div><p>A structure representing a quantum resonator component in a superconducting circuit.</p><p><strong>Fields</strong></p><ul><li><p><code>dim::Int</code>: The Hilbert space dimension of the resonator.</p></li><li><p><code>params::Dict</code>: Dictionary containing the physical parameters of the resonator.</p></li><li><p><code>H_op::qt.QuantumObject</code>: The Hamiltonian operator of the resonator.</p></li><li><p><code>eigenstates::Vector</code>: Vector of eigenstates of the resonator Hamiltonian.</p></li><li><p><code>eigenenergies::Vector</code>: Vector of eigenenergies corresponding to the eigenstates.</p></li><li><p><code>loss_ops::Dict</code>: Dictionary of loss (dissipation) operators associated with the resonator.</p></li><li><p><code>a_op::qt.QuantumObject</code>: The annihilation (lowering) operator for the resonator.</p></li><li><p><code>N_op::qt.QuantumObject</code>: The number operator for the resonator.</p></li></ul><p><strong>Description</strong></p><p>This structure encapsulates all relevant quantum properties and operators for a resonator component, facilitating simulation and analysis within superconducting circuit models.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Circuits/Components/Resonator.jl#L2-L19" target="_blank" rel="noreferrer">source</a><!--]--></span></details><h4 id="SNAIL" tabindex="-1">SNAIL <a class="header-anchor" href="#SNAIL" aria-label="Permalink to &quot;SNAIL {#SNAIL}&quot;">​</a></h4><h4 id="Transmon" tabindex="-1">Transmon <a class="header-anchor" href="#Transmon" aria-label="Permalink to &quot;Transmon {#Transmon}&quot;">​</a></h4><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Circuits.Transmon" href="#SuperconductingCircuits.Circuits.Transmon"><span class="jlbinding">SuperconductingCircuits.Circuits.Transmon</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Transmon</span></span></code></pre></div><p>A struct representing a transmon qubit component in a superconducting circuit.</p><p><strong>Fields</strong></p><ul><li><p><code>params::Dict</code>: Dictionary containing the physical parameters of the transmon.</p></li><li><p><code>eigenenergies::Vector</code>: Vector of eigenenergies computed for the transmon Hamiltonian.</p></li><li><p><code>eigenstates::Vector</code>: Vector of eigenstates corresponding to the eigenenergies.</p></li><li><p><code>H_op::qt.QuantumObject</code>: Truncated Hamiltonian operator for the transmon, represented as a quantum object.</p></li><li><p><code>dim::Int</code>: Hilbert space dimension used for truncation.</p></li><li><p><code>loss_ops::Dict</code>: Dictionary of loss (dissipation) operators relevant to the transmon.</p></li><li><p><code>H_op_full::qt.QuantumObject</code>: Full (untruncated) Hamiltonian operator for the transmon.</p></li><li><p><code>n_op_full::qt.QuantumObject</code>: Full (untruncated) charge operator (U(1) number operator).</p></li><li><p><code>n_op::qt.QuantumObject</code>: Truncated charge operator.</p></li></ul><p><strong>Description</strong></p><p>The <code>Transmon</code> struct encapsulates all relevant data and operators for simulating a transmon qubit, including its Hamiltonian, eigenstates, and loss mechanisms. It is designed for use in quantum circuit simulations and analysis.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Circuits/Components/Transmon.jl#L1-L19" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Circuits.init_transmon-Tuple{Any, Any, Any}" href="#SuperconductingCircuits.Circuits.init_transmon-Tuple{Any, Any, Any}"><span class="jlbinding">SuperconductingCircuits.Circuits.init_transmon</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">init_transmon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(EC, EJ, n_full, N; name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Transmon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ng </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kappa_c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">56</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), kappa_d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.2348024316109425e-5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Initialize a Transmon qubit Hamiltonian and associated operators.</p><p><strong>Arguments</strong></p><ul><li><p><code>EC::Real</code>: Charging energy of the transmon.</p></li><li><p><code>EJ::Real</code>: Josephson energy of the transmon.</p></li><li><p><code>n_full::Int</code>: Number of charge states to include in the full Hilbert space (dimension will be <code>2*n_full+1</code>).</p></li><li><p><code>N::Int</code>: Number of energy levels to keep in the truncated Hilbert space.</p></li><li><p><code>name::String</code>: (Optional) Name of the transmon instance. Defaults to <code>&quot;Transmon&quot;</code>.</p></li><li><p><code>ng::Real</code>: (Optional) Offset charge. Defaults to <code>0</code>.</p></li><li><p><code>kappa_c::Real</code>: (Optional) Collapse (relaxation) rate. Defaults to <code>1/(56*1000)</code>.</p></li><li><p><code>kappa_d::Real</code>: (Optional) Dephasing rate. Defaults to <code>1.2348024316109425e-5</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Transmon</code>: An instance of the <code>Transmon</code> type containing: <ul><li><p><code>params</code>: Dictionary of parameters used for initialization.</p></li><li><p><code>dim</code>: Truncated Hilbert space dimension.</p></li><li><p><code>H_op_full</code>: Full Hamiltonian operator.</p></li><li><p><code>H_op</code>: Truncated Hamiltonian operator.</p></li><li><p><code>n_op_full</code>: Full number operator.</p></li><li><p><code>n_op</code>: Truncated number operator.</p></li><li><p><code>eigenenergies</code>: Eigenenergies of the truncated Hamiltonian.</p></li><li><p><code>eigenstates</code>: Eigenstates of the truncated Hamiltonian.</p></li><li><p><code>loss_ops</code>: Dictionary of collapse (<code>&quot;Collapse&quot;</code>) and dephasing (<code>&quot;Dephasing&quot;</code>) operators.</p></li></ul></li></ul><p><strong>Notes</strong></p><ul><li><p>The function constructs the transmon Hamiltonian in the charge basis, diagonalizes it, and projects onto the lowest <code>N</code> energy eigenstates.</p></li><li><p>Collapse and dephasing operators are constructed in the truncated basis.</p></li><li><p>Hermiticity of operators is checked and enforced.</p></li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Circuits/Components/Transmon.jl#L35-L66" target="_blank" rel="noreferrer">source</a><!--]--></span></details><h3 id="Circuit-Utils" tabindex="-1">Circuit Utils <a class="header-anchor" href="#Circuit-Utils" aria-label="Permalink to &quot;Circuit Utils {#Circuit-Utils}&quot;">​</a></h3><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Circuits.add_operator!-Tuple{Circuit, AbstractArray{String}, String}" href="#SuperconductingCircuits.Circuits.add_operator!-Tuple{Circuit, AbstractArray{String}, String}"><span class="jlbinding">SuperconductingCircuits.Circuits.add_operator!</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_operator!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(circuit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Circuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{String}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; use_sparse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Adds a custom operator to the given <code>circuit</code> object.</p><p><strong>Arguments</strong></p><ul><li><p><code>circuit::Circuit</code>: The circuit to which the operator will be added.</p></li><li><p><code>operator::AbstractArray{String}</code>: An array of operator strings, one for each component in the circuit. The length must match the number of components in the circuit.</p></li><li><p><code>name::String</code>: The name under which the operator will be stored in the circuit.</p></li><li><p><code>use_sparse</code> (optional, default = <code>true</code>): Whether to convert the operator matrices to sparse format.</p></li></ul><p><strong>Description</strong></p><p>For each component in the circuit, parses and evaluates the corresponding operator string. If the operator is not defined (<code>nothing</code>), uses the identity operator for that component. Optionally converts each operator to a sparse matrix. The resulting operators are combined using a tensor product and stored in the circuit&#39;s <code>ops</code> dictionary under the given <code>name</code>. The original operator definitions are also stored in <code>circuit.stuff[&quot;ops_def&quot;]</code>.</p><p><strong>Throws</strong></p><ul><li>An error if the length of <code>operator</code> does not match the number of components in the circuit.</li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Circuits/CircuitUtils.jl#L1-L17" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Circuits.get_dressed_states-Tuple{QuantumToolbox.QuantumObject, AbstractArray{CircuitComponent}, Any}" href="#SuperconductingCircuits.Circuits.get_dressed_states-Tuple{QuantumToolbox.QuantumObject, AbstractArray{CircuitComponent}, Any}"><span class="jlbinding">SuperconductingCircuits.Circuits.get_dressed_states</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_dressed_states</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qt.QuantumObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, components</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{Component}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, interactions; step_number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the dressed states, energies, and orderings for a quantum system as interaction strengths are adiabatically turned on.</p><p><strong>Arguments</strong></p><ul><li><p><code>H0::qt.QuantumObject</code>: The initial (bare) Hamiltonian of the system.</p></li><li><p><code>components::AbstractArray{Component}</code>: Array of system components, each with a defined Hilbert space dimension and eigenstates.</p></li><li><p><code>interactions</code>: List of interaction specifications. Each interaction is an array where the first element is the coupling strength, and subsequent elements specify operators (or &quot;1&quot; for identity) for each component. The string &quot;hc&quot; can be included to add the Hermitian conjugate.</p></li><li><p><code>step_number</code>: (Optional) Number of steps in the adiabatic interpolation. Default is 20.</p></li><li><p><code>f</code>: (Optional) Function mapping the interpolation parameter (from 0 to 1) to the interaction scaling. Default is <code>x -&gt; x^3</code>.</p></li></ul><p><strong>Returns</strong></p><p>A vector containing:</p><ol><li><p><code>dressed_states::Dict</code>: Mapping from bare state tuples to the corresponding dressed state at the final step.</p></li><li><p><code>dressed_energies::Dict</code>: Mapping from bare state tuples to the corresponding dressed energy at the final step.</p></li><li><p><code>dressed_order::Vector{Tuple}</code>: Vector mapping the dressed state order (by energy) to the bare state tuple.</p></li></ol><p><strong>Description</strong></p><p>The function interpolates between the bare Hamiltonian and the fully interacting Hamiltonian by scaling the interaction terms according to <code>f</code>. At each step, it computes the eigenstates and energies, tracks the evolution of each bare state, and returns the dressed states, energies, and their order at the final step.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Circuits/CircuitUtils.jl#L39-L59" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Circuits.save-Tuple{Circuit, String}" href="#SuperconductingCircuits.Circuits.save-Tuple{Circuit, String}"><span class="jlbinding">SuperconductingCircuits.Circuits.save</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">save</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(circuit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Circuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Serialize and save the given <code>circuit</code> object to a file specified by <code>filename</code>.</p><p>The function collects the following information from the <code>circuit</code>:</p><ul><li><p><code>order</code>: The order of the circuit.</p></li><li><p><code>components</code>: A dictionary mapping component names to their parameters.</p></li><li><p><code>interactions</code>: A list of circuit interactions.</p></li><li><p><code>stuff</code>: Additional circuit data stored in the <code>stuff</code> field.</p></li></ul><p><strong>Arguments</strong></p><ul><li><p><code>circuit::Circuit</code>: The circuit object to be saved.</p></li><li><p><code>filename::String</code>: The path to the file where the circuit data will be saved.</p></li></ul><p><strong>Note</strong></p><p>The actual file writing operation is not implemented in this function.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Circuits/CircuitUtils.jl#L116-L133" target="_blank" rel="noreferrer">source</a><!--]--></span></details><h2 id="Dynamics" tabindex="-1">Dynamics <a class="header-anchor" href="#Dynamics" aria-label="Permalink to &quot;Dynamics {#Dynamics}&quot;">​</a></h2><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Dynamics.calibrate_drive-Tuple{QuantumToolbox.QuantumObjectEvolution, Any, Any, Function}" href="#SuperconductingCircuits.Dynamics.calibrate_drive-Tuple{QuantumToolbox.QuantumObjectEvolution, Any, Any, Function}"><span class="jlbinding">SuperconductingCircuits.Dynamics.calibrate_drive</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calibrate_drive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(drive_op</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qt.QobjEvo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, t_range0, psi0, to_min</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; samples_per_level</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, maxiters</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, approx_tol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, solver_kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), return_drive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, include_H</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calibrates the duration of a quantum drive by minimizing a user-specified cost function over a given time range.</p><p><strong>Arguments</strong></p><ul><li><p><code>drive_op::qt.QobjEvo</code>: The time-dependent drive operator (Hamiltonian) to be calibrated.</p></li><li><p><code>t_range0</code>: Initial time range (tuple or array) over which to search for the optimal drive duration.</p></li><li><p><code>psi0</code>: Initial quantum state for the evolution.</p></li><li><p><code>to_min::Function</code>: A function that takes the final state and returns a scalar value to be minimized (e.g., infidelity).</p></li><li><p><code>samples_per_level</code>: Number of time samples to evaluate per iteration (default: 5).</p></li><li><p><code>maxiters</code>: Maximum number of iterations for the calibration loop (default: 7).</p></li><li><p><code>tol</code>: Tolerance for the minimum value of the cost function to consider the calibration successful (default: 1e-3).</p></li><li><p><code>approx_tol</code>: Tolerance for considering two time points as approximately equal (default: 1e-8).</p></li><li><p><code>solver_kwargs</code>: Additional keyword arguments to pass to the ODE solver (default: empty dictionary).</p></li><li><p><code>return_drive</code>: If <code>true</code>, returns the calibrated drive (currently unused, default: true).</p></li><li><p><code>include_H</code>: If <code>true</code>, includes the Hamiltonian in the evolution (currently unused, default: true).</p></li><li><p><code>dt</code>: Time step for the evolution solver (default: 1e-2).</p></li></ul><p><strong>Returns</strong></p><ul><li>A two-element array <code>[best_time, best_fid]</code> where: <ul><li><p><code>best_time</code>: The optimal drive duration found.</p></li><li><p><code>best_fid</code>: The minimum value of the cost function achieved.</p></li></ul></li></ul><p><strong>Description</strong></p><p>This function iteratively samples the cost function over a shrinking time interval, searching for the drive duration that minimizes the user-provided <code>to_min</code> function. The search continues until the minimum value falls below the specified tolerance or the maximum number of iterations is reached.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Dynamics/Drives/DriveCalibration.jl#L1-L27" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Dynamics.find_resonance-Union{Tuple{T1}, Tuple{Any, Any, T1}} where T1&lt;:Dict" href="#SuperconductingCircuits.Dynamics.find_resonance-Union{Tuple{T1}, Tuple{Any, Any, T1}} where T1&lt;:Dict"><span class="jlbinding">SuperconductingCircuits.Dynamics.find_resonance</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_resonance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H_func, freqs, reference_states</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; show_plot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, plot_freq_offset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, plotxlabel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Drive Frequencies (GHz)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span></span></code></pre></div><p>Finds the resonance frequency and approximate drive time for a driven quantum system using Floquet theory.</p><p><strong>Arguments</strong></p><ul><li><p><code>H_func</code>: A function that generates the system Hamiltonian as a function of parameters.</p></li><li><p><code>freqs</code>: An array of drive frequencies (in GHz) to sweep over.</p></li><li><p><code>reference_states::T1</code>: A dictionary mapping state labels to reference states to track during the Floquet sweep.</p></li><li><p><code>show_plot</code>: (optional) If <code>true</code>, displays plots of the quasienergies and their differences. Default is <code>false</code>.</p></li><li><p><code>plot_freq_offset</code>: (optional) Frequency offset to apply to the x-axis of the plots. Default is <code>0</code>.</p></li><li><p><code>plotxlabel</code>: (optional) Label for the x-axis of the plots. Default is <code>&quot;Drive Frequencies (GHz)&quot;</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li>A two-element array: <ol><li><p>The resonance frequency (in GHz) where the minimum energy gap occurs.</p></li><li><p>The approximate drive time associated with the resonance.</p></li></ol></li></ul><p><strong>Description</strong></p><p>This function performs a sweep over the provided drive frequencies, computes the Floquet quasienergies for the specified reference states, and determines the resonance by fitting the minimum energy gap to a model function. Optionally, it can display plots of the quasienergies and their differences.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Dynamics/Drives/ResonanceFinder.jl#L1-L21" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Dynamics.floquet_sweep-Union{Tuple{T1}, Tuple{Any, Any, Any}} where T1&lt;:Dict" href="#SuperconductingCircuits.Dynamics.floquet_sweep-Union{Tuple{T1}, Tuple{Any, Any, Any}} where T1&lt;:Dict"><span class="jlbinding">SuperconductingCircuits.Dynamics.floquet_sweep</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floquet_sweep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H_func, sampling_points, T; sampling_times</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[], use_logging</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, states_to_track</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Any, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), propagator_kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Any, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Performs a parameter sweep to compute Floquet modes and quasienergies for a family of time-dependent Hamiltonians.</p><p><strong>Arguments</strong></p><ul><li><p><code>H_func</code>: A function that takes a parameter value from <code>sampling_points</code> and returns the corresponding Hamiltonian.</p></li><li><p><code>sampling_points</code>: An array of parameter values over which to perform the sweep.</p></li><li><p><code>T</code>: The period of the drive. Can be a scalar (applied to all points) or an array matching <code>sampling_points</code>.</p></li><li><p><code>sampling_times</code>: (Optional) Array of times at which to evaluate the Floquet modes for each parameter set. Defaults to zeros.</p></li><li><p><code>use_logging</code>: (Optional) If <code>true</code>, logs progress and status messages.</p></li><li><p><code>states_to_track</code>: (Optional) A dictionary of states to track across the sweep. If provided, state tracking is performed.</p></li><li><p><code>propagator_kwargs</code>: (Optional) Dictionary of keyword arguments to pass to the propagator used in Floquet basis calculation.</p></li></ul><p><strong>Returns</strong></p><p>A dictionary with the following keys:</p><ul><li><p><code>&quot;F_Modes&quot;</code>: Array of Floquet modes for each parameter set.</p></li><li><p><code>&quot;F_Energies&quot;</code>: Array of Floquet quasienergies for each parameter set.</p></li><li><p><code>&quot;Tracking&quot;</code>: (Optional) Results from state tracking, if <code>states_to_track</code> is provided.</p></li></ul><p><strong>Notes</strong></p><ul><li><p>If a parameter value in <code>sampling_points</code> is repeated, previously computed results are reused.</p></li><li><p>Progress is displayed using a progress bar if logging is enabled.</p></li><li><p>Requires <code>get_floquet_basis</code> and <code>Utils.state_tracker</code> to be defined elsewhere.</p></li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Dynamics/Floquet/Floquet_Sweep.jl#L1-L25" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Dynamics.get_FLZ_flattop-Tuple{Any, Any, Any, Any, Function, Any, Any, Any}" href="#SuperconductingCircuits.Dynamics.get_FLZ_flattop-Tuple{Any, Any, Any, Any, Function, Any, Any, Any}"><span class="jlbinding">SuperconductingCircuits.Dynamics.get_FLZ_flattop</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_FLZ_flattop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    H_op, drive_op, freq, epsilon, envelope_func, ramp_time, psi0, psi1;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n_theta_samples</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, number_eps_samples</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Determine the optimal flat-top duration for a Floquet-Landau-Zener (FLZ) protocol in a driven quantum system.</p><p><strong>Arguments</strong></p><ul><li><p><code>H_op</code>: Static system Hamiltonian.</p></li><li><p><code>drive_op</code>: Operator representing the drive interaction.</p></li><li><p><code>freq</code>: Drive frequency (Hz).</p></li><li><p><code>epsilon</code>: Drive amplitude.</p></li><li><p><code>envelope_func::Function</code>: Time-dependent envelope function for the drive pulse.</p></li><li><p><code>ramp_time</code>: Duration of the ramp segment (same time units as used elsewhere).</p></li><li><p><code>psi0</code>: Initial quantum state (e.g., ground state).</p></li><li><p><code>psi1</code>: Target quantum state (e.g., excited state).</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>dt</code>: Time step for numerical evolution. Defaults to <code>1/freq</code> if set to 0.</p></li><li><p><code>n_theta_samples</code>: Number of phase grid points for optimization (default: 100).</p></li><li><p><code>num_t_samples</code>: Number of time samples to evaluate the floquet modes (default: 10).</p></li><li><p><code>epsilons_to_sample</code>: Optional array of epsilon values to sample at each time step. If not provided, it is computed based on the envelope function.</p></li></ul><p><strong>Returns</strong></p><ul><li>The calibrated flat-top duration (same units as <code>ramp_time</code>) that aligns the system&#39;s evolution with the desired Floquet phase, facilitating high-fidelity state transfer.</li></ul><p><strong>Details</strong></p><p>This function simulates the system&#39;s evolution under a driven protocol, performing a Floquet analysis to optimize the phase accumulation. It searches for the flat-top time that best matches the target state, using grid search over phase and amplitude parameters. Diagnostic information about the Floquet frequency and phase is printed during execution.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Dynamics/Drives/DriveCalibration.jl#L78-L107" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Dynamics.get_floquet_basis-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}" href="#SuperconductingCircuits.Dynamics.get_floquet_basis-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}"><span class="jlbinding">SuperconductingCircuits.Dynamics.get_floquet_basis</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_floquet_basis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{qt.QuantumObject, qt.QobjEvo}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, T; t0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, propagator_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Compute the Floquet basis for a time-periodic Hamiltonian.</p><p><strong>Arguments</strong></p><ul><li><p><code>H::Union{qt.QuantumObject, qt.QobjEvo}</code>: The time-dependent Hamiltonian, either as a quantum object or a time-evolution operator.</p></li><li><p><code>T</code>: The period of the Hamiltonian.</p></li><li><p><code>t0</code>: (optional) Initial time. Defaults to <code>0</code>.</p></li><li><p><code>propagator_kwargs</code>: (optional) Dictionary of keyword arguments to pass to the propagator functions.</p></li></ul><p><strong>Returns</strong></p><ul><li>A tuple containing the Floquet quasi-energies and a function that returns the time-evolved Floquet modes at any given time.</li></ul><p><strong>Description</strong></p><p>This function computes the Floquet basis by:</p><ol><li><p>Calculating the propagator over one period.</p></li><li><p>Diagonalizing the propagator to obtain Floquet quasi-energies and modes.</p></li><li><p>Returning the quasi-energies and a function for propagating the Floquet modes in time.</p></li></ol><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Dynamics/Floquet/Floquet_Basis.jl#L1-L20" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Dynamics.get_propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}}" href="#SuperconductingCircuits.Dynamics.get_propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}}"><span class="jlbinding">SuperconductingCircuits.Dynamics.get_propagator</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_propagator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{qt.QobjEvo, qt.QuantumObject}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Constructs a <code>Propagator</code> object for the given Hamiltonian <code>H</code>, which can be either a <code>qt.QobjEvo</code> or a <code>qt.QuantumObject</code>.</p><p>The returned <code>Propagator</code> provides a function interface to compute the time-evolution operator for <code>H</code> over a specified time interval. The function accepts the final time <code>tf</code>, an optional initial time <code>ti</code> (default is 0), and an optional dictionary of solver keyword arguments <code>solver_kwargs</code>.</p><p><strong>Arguments</strong></p><ul><li><code>H::Union{qt.QobjEvo, qt.QuantumObject}</code>: The Hamiltonian for which the propagator is constructed.</li></ul><p><strong>Returns</strong></p><ul><li><code>Propagator</code>: An object that can be called to compute the propagator for the specified time interval and solver options.</li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Dynamics/Utils/Propagator.jl#L98-L110" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Dynamics.propagate_floquet_modes-NTuple{4, Any}" href="#SuperconductingCircuits.Dynamics.propagate_floquet_modes-NTuple{4, Any}"><span class="jlbinding">SuperconductingCircuits.Dynamics.propagate_floquet_modes</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">propagate_floquet_modes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(modes_t0, U, t, T; propagator_kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Propagates a set of Floquet modes from the initial time <code>t₀</code> to a later time <code>t</code> using the provided propagator <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>modes_t0</code>: Array of Floquet modes at the initial time <code>t₀</code>.</p></li><li><p><code>U</code>: A propagator object with an <code>eval</code> method, used to compute the time evolution operator.</p></li><li><p><code>t</code>: The target time to which the modes should be propagated.</p></li><li><p><code>T</code>: The period of the Floquet system.</p></li><li><p><code>propagator_kwargs</code>: (Optional) Dictionary of keyword arguments to pass to the propagator&#39;s <code>eval</code> method.</p></li></ul><p><strong>Returns</strong></p><ul><li>An array of Floquet modes at time <code>t</code>.</li></ul><p><strong>Notes</strong></p><ul><li><p>If <code>t</code> is an integer multiple of <code>T</code>, the function returns the initial modes unchanged.</p></li><li><p>Otherwise, the function computes the propagator for the time offset <code>t % T</code> and applies it to each mode.</p></li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Dynamics/Floquet/Floquet_Utils.jl#L1-L19" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Dynamics.propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}" href="#SuperconductingCircuits.Dynamics.propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}"><span class="jlbinding">SuperconductingCircuits.Dynamics.propagator</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">propagator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{qt.QobjEvo, qt.QuantumObject}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tf; ti </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, solver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vern9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), solver_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict{Any, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Compute the time-evolution operator (propagator) for a given time-dependent or time-independent Hamiltonian <code>H</code> from initial time <code>ti</code> to final time <code>tf</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>H::Union{qt.QobjEvo, qt.QuantumObject}</code>: The Hamiltonian, either as a time-dependent (<code>qt.QobjEvo</code>) or time-independent (<code>qt.QuantumObject</code>) quantum object.</p></li><li><p><code>tf</code>: The final time for propagation.</p></li><li><p><code>ti</code>: (optional) The initial time. Defaults to <code>0</code>.</p></li><li><p><code>solver</code>: (optional) The ODE solver to use from DifferentialEquations.jl. Defaults to <code>DE.Vern9()</code>.</p></li><li><p><code>solver_kwargs</code>: (optional) Additional keyword arguments to pass to the ODE solver.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>qt.Qobj</code>: The propagator (time-evolution operator) as a quantum object, mapping the system from time <code>ti</code> to <code>tf</code>.</li></ul><p><strong>Notes</strong></p><ul><li><p>The function internally constructs the ODE for the propagator in the Schrödinger picture and solves it using the specified solver.</p></li><li><p>If the Hamiltonian is sparse, the propagator is returned as a sparse matrix.</p></li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Dynamics/Utils/Propagator.jl#L20-L38" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Dynamics.Propagator" href="#SuperconductingCircuits.Dynamics.Propagator"><span class="jlbinding">SuperconductingCircuits.Dynamics.Propagator</span></a> <span class="VPBadge info jlObjectType jlType"><!--[-->Type<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Propagator</span></span></code></pre></div><p>A structure representing a quantum propagator for time evolution.</p><p><strong>Fields</strong></p><ul><li><p><code>H::Union{qt.QobjEvo, qt.QuantumObject}</code>: The Hamiltonian or time-dependent operator governing the system&#39;s dynamics. This can be a <code>qt.QobjEvo</code> for time-dependent Hamiltonians or a <code>qt.QuantumObject</code> for time-independent cases.</p></li><li><p><code>eval::Function</code>: A function that computes the propagator or evolves the quantum state, typically as a function of time and initial state.</p></li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Dynamics/Utils/Propagator.jl#L5-L13" target="_blank" rel="noreferrer">source</a><!--]--></span></details><h2 id="Utils" tabindex="-1">Utils <a class="header-anchor" href="#Utils" aria-label="Permalink to &quot;Utils {#Utils}&quot;">​</a></h2><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Utils.identity_wrapper-Tuple{Dict, Any}" href="#SuperconductingCircuits.Utils.identity_wrapper-Tuple{Dict, Any}"><span class="jlbinding">SuperconductingCircuits.Utils.identity_wrapper</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identity_wrapper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(𝕀̂_Dict</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Operator_Dict; order </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [])</span></span></code></pre></div><p>Constructs a tensor product of operators, replacing identity operators with those specified in <code>Operator_Dict</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>𝕀̂_Dict::Dict</code>: A dictionary mapping subsystem keys to identity operators.</p></li><li><p><code>Operator_Dict::Dict</code>: A dictionary mapping subsystem keys to operators that should replace the corresponding identities.</p></li><li><p><code>order::Vector</code> (optional): An array specifying the order of subsystems in the tensor product. If not provided, the order of keys in <code>𝕀̂_Dict</code> is used.</p></li></ul><p><strong>Returns</strong></p><ul><li>The tensor product (using <code>qt.tensor</code>) of the operators, with identities replaced as specified.</li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Utils/IdentityWrappers.jl#L1-L13" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Utils.state_tracker-Tuple{Vector, Dict}" href="#SuperconductingCircuits.Utils.state_tracker-Tuple{Vector, Dict}"><span class="jlbinding">SuperconductingCircuits.Utils.state_tracker</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state_tracker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state_history</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, states_to_track</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; other_sorts</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Any, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), use_logging</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Tracks the evolution of specified quantum states across a sequence of state histories.</p><p><strong>Arguments</strong></p><ul><li><p><code>state_history::Vector</code>: A vector where each element is a collection (e.g., vector or array) of quantum states at a given time step.</p></li><li><p><code>states_to_track::Dict</code>: A dictionary mapping state identifiers to their initial state vectors to be tracked.</p></li><li><p><code>other_sorts::Dict{Any, Any}</code> (optional): A dictionary mapping additional property names to arrays of properties, which are also tracked for each state and time step. Defaults to an empty dictionary.</p></li><li><p><code>use_logging::Bool</code> (optional): If <code>true</code>, enables debug and info logging for tracking progress and overlaps. Defaults to <code>true</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>history</code>: A multidimensional array (AxisArray or similar) indexed by state and step, where each entry is a dictionary containing: <ul><li><p><code>&quot;psi&quot;</code>: The tracked state vector at that step.</p></li><li><p><code>&quot;overlap&quot;</code>: The maximum overlap value found for the state at that step.</p></li><li><p>Additional keys for each property in <code>other_sorts</code>, containing their respective values.</p></li></ul></li></ul><p><strong>Description</strong></p><p>For each state specified in <code>states_to_track</code>, the function iteratively finds, at each time step, the state in <code>state_history</code> with the maximum overlap (squared inner product) with the previous step&#39;s tracked state. It records the state vector, overlap, and any additional properties provided in <code>other_sorts</code>. The function also ensures that the same state is not assigned to multiple tracked states at the same step, logging a warning if this occurs.</p><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Utils/StateTracking.jl#L1-L20" target="_blank" rel="noreferrer">source</a><!--]--></span></details><details class="jldocstring custom-block" open><summary><a id="SuperconductingCircuits.Utils.tostr-Tuple{Any}" href="#SuperconductingCircuits.Utils.tostr-Tuple{Any}"><span class="jlbinding">SuperconductingCircuits.Utils.tostr</span></a> <span class="VPBadge info jlObjectType jlMethod"><!--[-->Method<!--]--></span></summary><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tostr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span></span></code></pre></div><p>Converts the given object <code>obj</code> to its plain text string representation by using the <code>show</code> function with the <code>&quot;text/plain&quot;</code> MIME type.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: Any Julia object to be converted to a string.</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The plain text representation of <code>obj</code>.</li></ul><span class="VPBadge info source-link"><!--[--><a href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/4c4d4986af764eec8548dc664cd7bf673086241a/src/Utils/RandomThings.jl#L1-L11" target="_blank" rel="noreferrer">source</a><!--]--></span></details></div></div></main><footer class="VPDocFooter" data-v-83890dd9 data-v-4f9813fa><!--[--><!--]--><div class="edit-info" data-v-4f9813fa><div class="edit-link" data-v-4f9813fa><a class="VPLink link vp-external-link-icon no-icon edit-link-button" href="https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/edit/main/docs/src/resources/api.md" target="_blank" rel="noreferrer" data-v-4f9813fa><!--[--><span class="vpi-square-pen edit-link-icon" data-v-4f9813fa></span> Edit this page<!--]--></a></div><!----></div><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-4f9813fa><span class="visually-hidden" id="doc-footer-aria-label" data-v-4f9813fa>Pager</span><div class="pager" data-v-4f9813fa><a class="VPLink link pager-link prev" href="/SuperconductingCircuits.jl/previews/PR4/user_guide/dynamics/floquet/floquet" data-v-4f9813fa><!--[--><span class="desc" data-v-4f9813fa>Previous page</span><span class="title" data-v-4f9813fa>Floquet Tools</span><!--]--></a></div><div class="pager" data-v-4f9813fa><!----></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter has-sidebar" data-v-a9a9e638 data-v-c970a860><div class="container" data-v-c970a860><p class="message" data-v-c970a860>Made with <a href="https://documenter.juliadocs.org/stable/" target="_blank"><strong>Documenter.jl</strong></a>, <a href="https://vitepress.dev" target="_blank"><strong>VitePress</strong></a> and <a href="https://luxdl.github.io/DocumenterVitepress.jl/stable" target="_blank"><strong>DocumenterVitepress.jl</strong></a><br> Powered by the <a href="https://www.julialang.org" target="_blank">Julia Programming Language</a>.<br></p><p class="copyright" data-v-c970a860>© Copyright 2025.</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"getting_started_overview.md\":\"Cr3qmkih\",\"index.md\":\"D2BLOVN4\",\"resources_api.md\":\"CgC0m9Ul\",\"user_guide_circuits_building_circuits_building_circuits.md\":\"DjyPRSDP\",\"user_guide_circuits_circuit_elements_circuit_elements.md\":\"CGruzYil\",\"user_guide_dynamics_floquet_floquet.md\":\"Bkr9HYp9\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"SuperconductingCircuits.jl\",\"description\":\"Documentation for SuperconductingCircuits.jl\",\"base\":\"/SuperconductingCircuits.jl/previews/PR4/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"outline\":\"deep\",\"search\":{\"provider\":\"local\",\"options\":{\"detailedView\":true}},\"nav\":[{\"text\":\"Home\",\"link\":\"/index\"},{\"text\":\"Getting Started\",\"collapsed\":false,\"items\":[{\"text\":\"Overview\",\"link\":\"/getting_started/overview\"}]},{\"text\":\"User Guide\",\"collapsed\":false,\"items\":[{\"text\":\"Circuits\",\"collapsed\":false,\"items\":[{\"text\":\"Circuit Elements\",\"link\":\"/user_guide/circuits/circuit_elements/circuit_elements\"},{\"text\":\"Building Circuits\",\"link\":\"/user_guide/circuits/building_circuits/building_circuits\"}]},{\"text\":\"Dynamics\",\"collapsed\":false,\"items\":[{\"text\":\"Floquet Tools\",\"link\":\"/user_guide/dynamics/floquet/floquet\"}]}]},{\"text\":\"Resources\",\"collapsed\":false,\"items\":[{\"text\":\"API\",\"link\":\"/resources/api\"}]},{\"component\":\"VersionPicker\"}],\"sidebar\":[{\"text\":\"Home\",\"link\":\"/index\"},{\"text\":\"Getting Started\",\"collapsed\":false,\"items\":[{\"text\":\"Overview\",\"link\":\"/getting_started/overview\"}]},{\"text\":\"User Guide\",\"collapsed\":false,\"items\":[{\"text\":\"Circuits\",\"collapsed\":false,\"items\":[{\"text\":\"Circuit Elements\",\"link\":\"/user_guide/circuits/circuit_elements/circuit_elements\"},{\"text\":\"Building Circuits\",\"link\":\"/user_guide/circuits/building_circuits/building_circuits\"}]},{\"text\":\"Dynamics\",\"collapsed\":false,\"items\":[{\"text\":\"Floquet Tools\",\"link\":\"/user_guide/dynamics/floquet/floquet\"}]}]},{\"text\":\"Resources\",\"collapsed\":false,\"items\":[{\"text\":\"API\",\"link\":\"/resources/api\"}]}],\"editLink\":{\"pattern\":\"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/edit/main/docs/src/:path\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl\"}],\"footer\":{\"message\":\"Made with <a href=\\\"https://documenter.juliadocs.org/stable/\\\" target=\\\"_blank\\\"><strong>Documenter.jl</strong></a>, <a href=\\\"https://vitepress.dev\\\" target=\\\"_blank\\\"><strong>VitePress</strong></a> and <a href=\\\"https://luxdl.github.io/DocumenterVitepress.jl/stable\\\" target=\\\"_blank\\\"><strong>DocumenterVitepress.jl</strong></a><br> Powered by the <a href=\\\"https://www.julialang.org\\\" target=\\\"_blank\\\">Julia Programming Language</a>.<br>\",\"copyright\":\"© Copyright 2025.\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":true}");</script>
    
  </body>
</html>