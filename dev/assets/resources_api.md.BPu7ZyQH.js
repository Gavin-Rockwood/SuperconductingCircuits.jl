import{_ as r,C as l,c as p,o as c,j as e,a as o,aA as n,G as s,w as a}from"./chunks/framework.CePe9n1f.js";const U=JSON.parse('{"title":"SuperconductingCircuits.jl Documentation","description":"","frontmatter":{},"headers":[],"relativePath":"resources/api.md","filePath":"resources/api.md","lastUpdated":null}'),d={name:"resources/api.md"},u={class:"jldocstring custom-block",open:""},h={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},q={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},w={class:"jldocstring custom-block",open:""},O={class:"jldocstring custom-block",open:""},B={class:"jldocstring custom-block",open:""};function R(H,i,I,Q,P,V){const t=l("Badge");return c(),p("div",null,[i[92]||(i[92]=e("h1",{id:"SuperconductingCircuits.jl-Documentation",tabindex:"-1"},[o("SuperconductingCircuits.jl Documentation "),e("a",{class:"header-anchor",href:"#SuperconductingCircuits.jl-Documentation","aria-label":'Permalink to "SuperconductingCircuits.jl Documentation {#SuperconductingCircuits.jl-Documentation}"'},"​")],-1)),i[93]||(i[93]=e("h2",{id:"Circuits",tabindex:"-1"},[o("Circuits "),e("a",{class:"header-anchor",href:"#Circuits","aria-label":'Permalink to "Circuits {#Circuits}"'},"​")],-1)),e("details",u,[e("summary",null,[i[0]||(i[0]=e("a",{id:"SuperconductingCircuits.Circuits.init_circuit-Tuple{AbstractArray{Component}, Any}",href:"#SuperconductingCircuits.Circuits.init_circuit-Tuple{AbstractArray{Component}, Any}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.init_circuit")],-1)),i[1]||(i[1]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[3]||(i[3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">init_circuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(components</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{Component}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, interactions; operators_to_add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{String, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), use_sparse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dressed_kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Initialize a quantum circuit from a list of components and their interactions.</p><p><strong>Arguments</strong></p><ul><li><p><code>components::AbstractArray{Component}</code>: An array of <code>Component</code> objects representing the subsystems of the circuit.</p></li><li><p><code>interactions</code>: A collection describing the interactions between components. Each interaction is typically a tuple or array where the first element is the coupling strength and the remaining elements specify the operators for each component.</p></li><li><p><code>operators_to_add=Dict{String, Any}()</code>: (Optional) A dictionary of additional operators to add to the circuit, keyed by operator name.</p></li><li><p><code>use_sparse=true</code>: (Optional) If <code>true</code>, use sparse matrix representations for operators and Hamiltonians.</p></li><li><p><code>dressed_kwargs=Dict{Symbol, Any}()</code>: (Optional) Keyword arguments passed to the dressed state calculation, such as <code>:f</code> (function for transformation) and <code>:step_number</code> (number of steps).</p></li></ul><p><strong>Returns</strong></p><ul><li><code>circuit::Circuit</code>: An initialized <code>Circuit</code> object containing the Hamiltonian, dressed states and energies, loss operators, component dictionary, and other relevant circuit information.</li></ul><p><strong>Details</strong></p><ul><li><p>Constructs the total Hilbert space dimensions and identity operators for each component.</p></li><li><p>Builds the bare Hamiltonian (<code>H_op_0</code>) and adds interaction terms to form the full Hamiltonian (<code>H_op</code>).</p></li><li><p>Calculates dressed states and energies using <code>get_dressed_states</code>.</p></li><li><p>Assembles loss operators for each component.</p></li><li><p>Organizes components and other circuit data into a <code>Circuit</code> struct.</p></li><li><p>Optionally adds user-specified operators to the circuit.</p></li></ul><hr><hr><p><strong>Overloaded As:</strong></p><hr><p><strong>init_circuit(components::AbstractArray{Dict}, types, interactions; kwargs...)</strong></p><p>Instead of taking in a list of initialized circuit elements, this takes in a list of parameter dictionaries and a list of of the corresponding circuit element types instead.</p><p><strong>Arguments</strong></p><ul><li><p><code>components::AbstractArray{Dict}</code>: An array of dictionaries, each containing the parameters for a circuit component.</p></li><li><p><code>types</code>: An array specifying the type of each component, used to select the appropriate constructor from <code>Component_inits</code>.</p></li><li><p><code>interactions</code>: Data structure describing the interactions between components.</p></li><li><p><code>kwargs...</code>: Additional keyword arguments passed to the underlying <code>init_circuit</code> method.</p></li></ul>',16)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[2]||(i[2]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Circuits/CircuitConstructor.jl#L1-L36",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[2]})]),i[94]||(i[94]=e("h3",{id:"Components",tabindex:"-1"},[o("Components "),e("a",{class:"header-anchor",href:"#Components","aria-label":'Permalink to "Components {#Components}"'},"​")],-1)),i[95]||(i[95]=e("h4",{id:"Qubit",tabindex:"-1"},[o("Qubit "),e("a",{class:"header-anchor",href:"#Qubit","aria-label":'Permalink to "Qubit {#Qubit}"'},"​")],-1)),e("details",h,[e("summary",null,[i[4]||(i[4]=e("a",{id:"SuperconductingCircuits.Circuits.Qubit",href:"#SuperconductingCircuits.Circuits.Qubit"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.Qubit")],-1)),i[5]||(i[5]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[7]||(i[7]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Qubit</span></span></code></pre></div><p>A structure representing a quantum bit (qubit) component in a superconducting circuit.</p><p><strong>Fields</strong></p><ul><li><p><code>dim::Int</code>: The Hilbert space dimension of the qubit (Always 2).</p></li><li><p><code>params::Dict</code>: Dictionary containing the physical parameters of the qubit.</p></li><li><p><code>H_op::qt.QuantumObject</code>: The Hamiltonian operator of the qubit, represented as a quantum object.</p></li><li><p><code>eigenstates::Vector</code>: Vector containing the eigenstates of the qubit Hamiltonian.</p></li><li><p><code>eigenenergies::Vector</code>: Vector containing the eigenenergies corresponding to the eigenstates.</p></li><li><p><code>loss_ops::Dict</code>: Dictionary of loss (dissipation) operators associated with the qubit.</p></li><li><p><code>freq::Float64</code>: The transition frequency of the qubit.</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[6]||(i[6]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Circuits/Components/Qubit.jl#L1-L14",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[6]})]),e("details",g,[e("summary",null,[i[8]||(i[8]=e("a",{id:"SuperconductingCircuits.Circuits.init_qubit-Tuple{Any}",href:"#SuperconductingCircuits.Circuits.init_qubit-Tuple{Any}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.init_qubit")],-1)),i[9]||(i[9]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[11]||(i[11]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">init_qubit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(freq; name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Qubit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Initialize a <code>Qubit</code> object with the specified transition frequency <code>freq</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>freq::Number</code>: The transition frequency of the qubit.</p></li><li><p><code>name::String</code> (optional): The name of the qubit. Defaults to <code>&quot;Qubit&quot;</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Qubit</code>: An initialized <code>Qubit</code> object containing the Hamiltonian operator, eigenenergies, eigenstates, and other parameters.</li></ul><p><strong>Details</strong></p><p>The function constructs the qubit Hamiltonian as <code>H_op = freq * qt.sigmaz() / 2</code>, computes its eigenenergies and eigenstates, and returns a <code>Qubit</code> object with these properties.</p>',8)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[10]||(i[10]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Circuits/Components/Qubit.jl#L29-L43",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[10]})]),e("details",k,[e("summary",null,[i[12]||(i[12]=e("a",{id:"SuperconductingCircuits.Circuits.init_qubit-Tuple{T} where T<:Dict",href:"#SuperconductingCircuits.Circuits.init_qubit-Tuple{T} where T<:Dict"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.init_qubit")],-1)),i[13]||(i[13]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[15]||(i[15]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">init_qubit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Params</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict</span></span></code></pre></div><p>Initializes a qubit using a dictionary of parameters.</p><p><strong>Arguments</strong></p><ul><li><code>Params::Dict</code>: A dictionary containing at least the key <code>:freq</code> (the qubit frequency) and any additional keyword parameters required for qubit initialization.</li></ul><p><strong>Returns</strong></p><ul><li>The result of calling <code>init_qubit</code> with the extracted frequency and remaining parameters.</li></ul><p><strong>Notes</strong></p><ul><li><p>The function makes a deep copy of the input dictionary to avoid mutating the original.</p></li><li><p>The <code>:freq</code> key is extracted and removed from the dictionary before passing the remaining parameters as keyword arguments.</p></li></ul><p><strong>Example</strong></p>',9)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[14]||(i[14]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Circuits/Components/Qubit.jl#L54-L70",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[14]})]),i[96]||(i[96]=e("h4",{id:"Resonator",tabindex:"-1"},[o("Resonator "),e("a",{class:"header-anchor",href:"#Resonator","aria-label":'Permalink to "Resonator {#Resonator}"'},"​")],-1)),e("details",m,[e("summary",null,[i[16]||(i[16]=e("a",{id:"SuperconductingCircuits.Circuits.Resonator",href:"#SuperconductingCircuits.Circuits.Resonator"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.Resonator")],-1)),i[17]||(i[17]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[19]||(i[19]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Resonator</span></span></code></pre></div><p>A structure representing a quantum resonator component in a superconducting circuit.</p><p><strong>Fields</strong></p><ul><li><p><code>dim::Int</code>: The Hilbert space dimension of the resonator.</p></li><li><p><code>params::Dict</code>: Dictionary containing the physical parameters of the resonator.</p></li><li><p><code>H_op::qt.QuantumObject</code>: The Hamiltonian operator of the resonator.</p></li><li><p><code>eigenstates::Vector</code>: Vector of eigenstates of the resonator Hamiltonian.</p></li><li><p><code>eigenenergies::Vector</code>: Vector of eigenenergies corresponding to the eigenstates.</p></li><li><p><code>loss_ops::Dict</code>: Dictionary of loss (dissipation) operators associated with the resonator.</p></li><li><p><code>a_op::qt.QuantumObject</code>: The annihilation (lowering) operator for the resonator.</p></li><li><p><code>N_op::qt.QuantumObject</code>: The number operator for the resonator.</p></li></ul><p><strong>Description</strong></p><p>This structure encapsulates all relevant quantum properties and operators for a resonator component, facilitating simulation and analysis within superconducting circuit models.</p>',6)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[18]||(i[18]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Circuits/Components/Resonator.jl#L2-L19",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[18]})]),i[97]||(i[97]=e("h4",{id:"SNAIL",tabindex:"-1"},[o("SNAIL "),e("a",{class:"header-anchor",href:"#SNAIL","aria-label":'Permalink to "SNAIL {#SNAIL}"'},"​")],-1)),i[98]||(i[98]=e("h4",{id:"Transmon",tabindex:"-1"},[o("Transmon "),e("a",{class:"header-anchor",href:"#Transmon","aria-label":'Permalink to "Transmon {#Transmon}"'},"​")],-1)),e("details",y,[e("summary",null,[i[20]||(i[20]=e("a",{id:"SuperconductingCircuits.Circuits.Transmon",href:"#SuperconductingCircuits.Circuits.Transmon"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.Transmon")],-1)),i[21]||(i[21]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[23]||(i[23]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Transmon</span></span></code></pre></div><p>A struct representing a transmon qubit component in a superconducting circuit.</p><p><strong>Fields</strong></p><ul><li><p><code>params::Dict</code>: Dictionary containing the physical parameters of the transmon.</p></li><li><p><code>eigenenergies::Vector</code>: Vector of eigenenergies computed for the transmon Hamiltonian.</p></li><li><p><code>eigenstates::Vector</code>: Vector of eigenstates corresponding to the eigenenergies.</p></li><li><p><code>H_op::qt.QuantumObject</code>: Truncated Hamiltonian operator for the transmon, represented as a quantum object.</p></li><li><p><code>dim::Int</code>: Hilbert space dimension used for truncation.</p></li><li><p><code>loss_ops::Dict</code>: Dictionary of loss (dissipation) operators relevant to the transmon.</p></li><li><p><code>H_op_full::qt.QuantumObject</code>: Full (untruncated) Hamiltonian operator for the transmon.</p></li><li><p><code>n_op_full::qt.QuantumObject</code>: Full (untruncated) charge operator (U(1) number operator).</p></li><li><p><code>n_op::qt.QuantumObject</code>: Truncated charge operator.</p></li></ul><p><strong>Description</strong></p><p>The <code>Transmon</code> struct encapsulates all relevant data and operators for simulating a transmon qubit, including its Hamiltonian, eigenstates, and loss mechanisms. It is designed for use in quantum circuit simulations and analysis.</p>',6)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[22]||(i[22]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Circuits/Components/Transmon.jl#L1-L19",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[22]})]),e("details",f,[e("summary",null,[i[24]||(i[24]=e("a",{id:"SuperconductingCircuits.Circuits.init_transmon-Tuple{Any, Any, Any}",href:"#SuperconductingCircuits.Circuits.init_transmon-Tuple{Any, Any, Any}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.init_transmon")],-1)),i[25]||(i[25]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[27]||(i[27]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">init_transmon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(EC, EJ, n_full, N; name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Transmon&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, ng </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, kappa_c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">56</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), kappa_d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.2348024316109425e-5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Initialize a Transmon qubit Hamiltonian and associated operators.</p><p><strong>Arguments</strong></p><ul><li><p><code>EC::Real</code>: Charging energy of the transmon.</p></li><li><p><code>EJ::Real</code>: Josephson energy of the transmon.</p></li><li><p><code>n_full::Int</code>: Number of charge states to include in the full Hilbert space (dimension will be <code>2*n_full+1</code>).</p></li><li><p><code>N::Int</code>: Number of energy levels to keep in the truncated Hilbert space.</p></li><li><p><code>name::String</code>: (Optional) Name of the transmon instance. Defaults to <code>&quot;Transmon&quot;</code>.</p></li><li><p><code>ng::Real</code>: (Optional) Offset charge. Defaults to <code>0</code>.</p></li><li><p><code>kappa_c::Real</code>: (Optional) Collapse (relaxation) rate. Defaults to <code>1/(56*1000)</code>.</p></li><li><p><code>kappa_d::Real</code>: (Optional) Dephasing rate. Defaults to <code>1.2348024316109425e-5</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>Transmon</code>: An instance of the <code>Transmon</code> type containing: <ul><li><p><code>params</code>: Dictionary of parameters used for initialization.</p></li><li><p><code>dim</code>: Truncated Hilbert space dimension.</p></li><li><p><code>H_op_full</code>: Full Hamiltonian operator.</p></li><li><p><code>H_op</code>: Truncated Hamiltonian operator.</p></li><li><p><code>n_op_full</code>: Full number operator.</p></li><li><p><code>n_op</code>: Truncated number operator.</p></li><li><p><code>eigenenergies</code>: Eigenenergies of the truncated Hamiltonian.</p></li><li><p><code>eigenstates</code>: Eigenstates of the truncated Hamiltonian.</p></li><li><p><code>loss_ops</code>: Dictionary of collapse (<code>&quot;Collapse&quot;</code>) and dephasing (<code>&quot;Dephasing&quot;</code>) operators.</p></li></ul></li></ul><p><strong>Notes</strong></p><ul><li><p>The function constructs the transmon Hamiltonian in the charge basis, diagonalizes it, and projects onto the lowest <code>N</code> energy eigenstates.</p></li><li><p>Collapse and dephasing operators are constructed in the truncated basis.</p></li><li><p>Hermiticity of operators is checked and enforced.</p></li></ul>',8)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[26]||(i[26]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Circuits/Components/Transmon.jl#L35-L66",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[26]})]),i[99]||(i[99]=e("h3",{id:"Circuit-Utils",tabindex:"-1"},[o("Circuit Utils "),e("a",{class:"header-anchor",href:"#Circuit-Utils","aria-label":'Permalink to "Circuit Utils {#Circuit-Utils}"'},"​")],-1)),e("details",b,[e("summary",null,[i[28]||(i[28]=e("a",{id:"SuperconductingCircuits.Circuits.add_operator!-Tuple{Circuit, AbstractArray{String}, String}",href:"#SuperconductingCircuits.Circuits.add_operator!-Tuple{Circuit, AbstractArray{String}, String}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.add_operator!")],-1)),i[29]||(i[29]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[31]||(i[31]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">add_operator!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(circuit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Circuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, operator</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{String}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, name</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; use_sparse</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Adds a custom operator to the given <code>circuit</code> object.</p><p><strong>Arguments</strong></p><ul><li><p><code>circuit::Circuit</code>: The circuit to which the operator will be added.</p></li><li><p><code>operator::AbstractArray{String}</code>: An array of operator strings, one for each component in the circuit. The length must match the number of components in the circuit.</p></li><li><p><code>name::String</code>: The name under which the operator will be stored in the circuit.</p></li><li><p><code>use_sparse</code> (optional, default = <code>true</code>): Whether to convert the operator matrices to sparse format.</p></li></ul><p><strong>Description</strong></p><p>For each component in the circuit, parses and evaluates the corresponding operator string. If the operator is not defined (<code>nothing</code>), uses the identity operator for that component. Optionally converts each operator to a sparse matrix. The resulting operators are combined using a tensor product and stored in the circuit&#39;s <code>ops</code> dictionary under the given <code>name</code>. The original operator definitions are also stored in <code>circuit.stuff[&quot;ops_def&quot;]</code>.</p><p><strong>Throws</strong></p><ul><li>An error if the length of <code>operator</code> does not match the number of components in the circuit.</li></ul>',8)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[30]||(i[30]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Circuits/CircuitUtils.jl#L1-L17",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[30]})]),e("details",_,[e("summary",null,[i[32]||(i[32]=e("a",{id:"SuperconductingCircuits.Circuits.get_dressed_states-Tuple{QuantumToolbox.QuantumObject, AbstractArray{Component}, Any}",href:"#SuperconductingCircuits.Circuits.get_dressed_states-Tuple{QuantumToolbox.QuantumObject, AbstractArray{Component}, Any}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.get_dressed_states")],-1)),i[33]||(i[33]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[35]||(i[35]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_dressed_states</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qt.QuantumObject</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, components</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractArray{Component}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, interactions; step_number</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">^</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Compute the dressed states, energies, and orderings for a quantum system as interaction strengths are adiabatically turned on.</p><p><strong>Arguments</strong></p><ul><li><p><code>H0::qt.QuantumObject</code>: The initial (bare) Hamiltonian of the system.</p></li><li><p><code>components::AbstractArray{Component}</code>: Array of system components, each with a defined Hilbert space dimension and eigenstates.</p></li><li><p><code>interactions</code>: List of interaction specifications. Each interaction is an array where the first element is the coupling strength, and subsequent elements specify operators (or &quot;1&quot; for identity) for each component. The string &quot;hc&quot; can be included to add the Hermitian conjugate.</p></li><li><p><code>step_number</code>: (Optional) Number of steps in the adiabatic interpolation. Default is 20.</p></li><li><p><code>f</code>: (Optional) Function mapping the interpolation parameter (from 0 to 1) to the interaction scaling. Default is <code>x -&gt; x^3</code>.</p></li></ul><p><strong>Returns</strong></p><p>A vector containing:</p><ol><li><p><code>dressed_states::Dict</code>: Mapping from bare state tuples to the corresponding dressed state at the final step.</p></li><li><p><code>dressed_energies::Dict</code>: Mapping from bare state tuples to the corresponding dressed energy at the final step.</p></li><li><p><code>dressed_order::Vector{Tuple}</code>: Vector mapping the dressed state order (by energy) to the bare state tuple.</p></li></ol><p><strong>Description</strong></p><p>The function interpolates between the bare Hamiltonian and the fully interacting Hamiltonian by scaling the interaction terms according to <code>f</code>. At each step, it computes the eigenstates and energies, tracks the evolution of each bare state, and returns the dressed states, energies, and their order at the final step.</p>',9)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[34]||(i[34]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Circuits/CircuitUtils.jl#L39-L59",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[34]})]),e("details",C,[e("summary",null,[i[36]||(i[36]=e("a",{id:"SuperconductingCircuits.Circuits.save-Tuple{Circuit, String}",href:"#SuperconductingCircuits.Circuits.save-Tuple{Circuit, String}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Circuits.save")],-1)),i[37]||(i[37]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[39]||(i[39]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">save</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(circuit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Circuit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, filename</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Serialize and save the given <code>circuit</code> object to a file specified by <code>filename</code>.</p><p>The function collects the following information from the <code>circuit</code>:</p><ul><li><p><code>order</code>: The order of the circuit.</p></li><li><p><code>components</code>: A dictionary mapping component names to their parameters.</p></li><li><p><code>interactions</code>: A list of circuit interactions.</p></li><li><p><code>stuff</code>: Additional circuit data stored in the <code>stuff</code> field.</p></li></ul><p><strong>Arguments</strong></p><ul><li><p><code>circuit::Circuit</code>: The circuit object to be saved.</p></li><li><p><code>filename::String</code>: The path to the file where the circuit data will be saved.</p></li></ul><p><strong>Note</strong></p><p>The actual file writing operation is not implemented in this function.</p>',8)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[38]||(i[38]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Circuits/CircuitUtils.jl#L116-L133",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[38]})]),i[100]||(i[100]=e("h2",{id:"Dynamics",tabindex:"-1"},[o("Dynamics "),e("a",{class:"header-anchor",href:"#Dynamics","aria-label":'Permalink to "Dynamics {#Dynamics}"'},"​")],-1)),e("details",E,[e("summary",null,[i[40]||(i[40]=e("a",{id:"SuperconductingCircuits.Dynamics.calibrate_drive-Tuple{QuantumToolbox.QuantumObjectEvolution, Any, Any, Function}",href:"#SuperconductingCircuits.Dynamics.calibrate_drive-Tuple{QuantumToolbox.QuantumObjectEvolution, Any, Any, Function}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.calibrate_drive")],-1)),i[41]||(i[41]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[43]||(i[43]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">calibrate_drive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(drive_op</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">qt.QobjEvo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, t_range0, psi0, to_min</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; samples_per_level</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, maxiters</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, approx_tol</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-8</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, solver_kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), return_drive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, include_H</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, dt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1e-2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Calibrates the duration of a quantum drive by minimizing a user-specified cost function over a given time range.</p><p><strong>Arguments</strong></p><ul><li><p><code>drive_op::qt.QobjEvo</code>: The time-dependent drive operator (Hamiltonian) to be calibrated.</p></li><li><p><code>t_range0</code>: Initial time range (tuple or array) over which to search for the optimal drive duration.</p></li><li><p><code>psi0</code>: Initial quantum state for the evolution.</p></li><li><p><code>to_min::Function</code>: A function that takes the final state and returns a scalar value to be minimized (e.g., infidelity).</p></li><li><p><code>samples_per_level</code>: Number of time samples to evaluate per iteration (default: 5).</p></li><li><p><code>maxiters</code>: Maximum number of iterations for the calibration loop (default: 7).</p></li><li><p><code>tol</code>: Tolerance for the minimum value of the cost function to consider the calibration successful (default: 1e-3).</p></li><li><p><code>approx_tol</code>: Tolerance for considering two time points as approximately equal (default: 1e-8).</p></li><li><p><code>solver_kwargs</code>: Additional keyword arguments to pass to the ODE solver (default: empty dictionary).</p></li><li><p><code>return_drive</code>: If <code>true</code>, returns the calibrated drive (currently unused, default: true).</p></li><li><p><code>include_H</code>: If <code>true</code>, includes the Hamiltonian in the evolution (currently unused, default: true).</p></li><li><p><code>dt</code>: Time step for the evolution solver (default: 1e-2).</p></li></ul><p><strong>Returns</strong></p><ul><li>A two-element array <code>[best_time, best_fid]</code> where: <ul><li><p><code>best_time</code>: The optimal drive duration found.</p></li><li><p><code>best_fid</code>: The minimum value of the cost function achieved.</p></li></ul></li></ul><p><strong>Description</strong></p><p>This function iteratively samples the cost function over a shrinking time interval, searching for the drive duration that minimizes the user-provided <code>to_min</code> function. The search continues until the minimum value falls below the specified tolerance or the maximum number of iterations is reached.</p>',8)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[42]||(i[42]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Dynamics/Drives/DriveCalibration.jl#L1-L27",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[42]})]),e("details",T,[e("summary",null,[i[44]||(i[44]=e("a",{id:"SuperconductingCircuits.Dynamics.find_resonance-Union{Tuple{T1}, Tuple{Any, Any, T1}} where T1<:Dict",href:"#SuperconductingCircuits.Dynamics.find_resonance-Union{Tuple{T1}, Tuple{Any, Any, T1}} where T1<:Dict"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.find_resonance")],-1)),i[45]||(i[45]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[47]||(i[47]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">find_resonance</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H_func, freqs, reference_states</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">T1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; show_plot</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, plot_freq_offset</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, plotxlabel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Drive Frequencies (GHz)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> T1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict</span></span></code></pre></div><p>Finds the resonance frequency and approximate drive time for a driven quantum system using Floquet theory.</p><p><strong>Arguments</strong></p><ul><li><p><code>H_func</code>: A function that generates the system Hamiltonian as a function of parameters.</p></li><li><p><code>freqs</code>: An array of drive frequencies (in GHz) to sweep over.</p></li><li><p><code>reference_states::T1</code>: A dictionary mapping state labels to reference states to track during the Floquet sweep.</p></li><li><p><code>show_plot</code>: (optional) If <code>true</code>, displays plots of the quasienergies and their differences. Default is <code>false</code>.</p></li><li><p><code>plot_freq_offset</code>: (optional) Frequency offset to apply to the x-axis of the plots. Default is <code>0</code>.</p></li><li><p><code>plotxlabel</code>: (optional) Label for the x-axis of the plots. Default is <code>&quot;Drive Frequencies (GHz)&quot;</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li>A two-element array: <ol><li><p>The resonance frequency (in GHz) where the minimum energy gap occurs.</p></li><li><p>The approximate drive time associated with the resonance.</p></li></ol></li></ul><p><strong>Description</strong></p><p>This function performs a sweep over the provided drive frequencies, computes the Floquet quasienergies for the specified reference states, and determines the resonance by fitting the minimum energy gap to a model function. Optionally, it can display plots of the quasienergies and their differences.</p>',8)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[46]||(i[46]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Dynamics/Drives/ResonanceFinder.jl#L1-L21",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[46]})]),e("details",v,[e("summary",null,[i[48]||(i[48]=e("a",{id:"SuperconductingCircuits.Dynamics.floquet_sweep-Union{Tuple{T1}, Tuple{Any, Any, Any}} where T1<:Dict",href:"#SuperconductingCircuits.Dynamics.floquet_sweep-Union{Tuple{T1}, Tuple{Any, Any, Any}} where T1<:Dict"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.floquet_sweep")],-1)),i[49]||(i[49]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[51]||(i[51]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">floquet_sweep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H_func, sampling_points, T; sampling_times</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[], use_logging</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, states_to_track</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Any, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), propagator_kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Any, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Performs a parameter sweep to compute Floquet modes and quasienergies for a family of time-dependent Hamiltonians.</p><p><strong>Arguments</strong></p><ul><li><p><code>H_func</code>: A function that takes a parameter value from <code>sampling_points</code> and returns the corresponding Hamiltonian.</p></li><li><p><code>sampling_points</code>: An array of parameter values over which to perform the sweep.</p></li><li><p><code>T</code>: The period of the drive. Can be a scalar (applied to all points) or an array matching <code>sampling_points</code>.</p></li><li><p><code>sampling_times</code>: (Optional) Array of times at which to evaluate the Floquet modes for each parameter set. Defaults to zeros.</p></li><li><p><code>use_logging</code>: (Optional) If <code>true</code>, logs progress and status messages.</p></li><li><p><code>states_to_track</code>: (Optional) A dictionary of states to track across the sweep. If provided, state tracking is performed.</p></li><li><p><code>propagator_kwargs</code>: (Optional) Dictionary of keyword arguments to pass to the propagator used in Floquet basis calculation.</p></li></ul><p><strong>Returns</strong></p><p>A dictionary with the following keys:</p><ul><li><p><code>&quot;F_Modes&quot;</code>: Array of Floquet modes for each parameter set.</p></li><li><p><code>&quot;F_Energies&quot;</code>: Array of Floquet quasienergies for each parameter set.</p></li><li><p><code>&quot;Tracking&quot;</code>: (Optional) Results from state tracking, if <code>states_to_track</code> is provided.</p></li></ul><p><strong>Notes</strong></p><ul><li><p>If a parameter value in <code>sampling_points</code> is repeated, previously computed results are reused.</p></li><li><p>Progress is displayed using a progress bar if logging is enabled.</p></li><li><p>Requires <code>get_floquet_basis</code> and <code>Utils.state_tracker</code> to be defined elsewhere.</p></li></ul>',9)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[50]||(i[50]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Dynamics/Floquet/Floquet_Sweep.jl#L1-L25",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[50]})]),e("details",A,[e("summary",null,[i[52]||(i[52]=e("a",{id:"SuperconductingCircuits.Dynamics.get_FLZ_flattop-Tuple{Any, Any, Any, Any, Function, Any, Any, Any}",href:"#SuperconductingCircuits.Dynamics.get_FLZ_flattop-Tuple{Any, Any, Any, Any, Function, Any, Any, Any}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.get_FLZ_flattop")],-1)),i[53]||(i[53]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[55]||(i[55]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_FLZ_flattop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    H_op, drive_op, freq, epsilon, envelope_func, ramp_time, psi0, psi1;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    dt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, n_theta_samples</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, number_eps_samples</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Determine the optimal flat-top duration for a Floquet-Landau-Zener (FLZ) protocol in a driven quantum system.</p><p><strong>Arguments</strong></p><ul><li><p><code>H_op</code>: Static system Hamiltonian.</p></li><li><p><code>drive_op</code>: Operator representing the drive interaction.</p></li><li><p><code>freq</code>: Drive frequency (Hz).</p></li><li><p><code>epsilon</code>: Drive amplitude.</p></li><li><p><code>envelope_func::Function</code>: Time-dependent envelope function for the drive pulse.</p></li><li><p><code>ramp_time</code>: Duration of the ramp segment (same time units as used elsewhere).</p></li><li><p><code>psi0</code>: Initial quantum state (e.g., ground state).</p></li><li><p><code>psi1</code>: Target quantum state (e.g., excited state).</p></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><p><code>dt</code>: Time step for numerical evolution. Defaults to <code>1/freq</code> if set to 0.</p></li><li><p><code>n_theta_samples</code>: Number of phase grid points for optimization (default: 100).</p></li><li><p><code>num_t_samples</code>: Number of time samples to evaluate the floquet modes (default: 10).</p></li><li><p><code>epsilons_to_sample</code>: Optional array of epsilon values to sample at each time step. If not provided, it is computed based on the envelope function.</p></li></ul><p><strong>Returns</strong></p><ul><li>The calibrated flat-top duration (same units as <code>ramp_time</code>) that aligns the system&#39;s evolution with the desired Floquet phase, facilitating high-fidelity state transfer.</li></ul><p><strong>Details</strong></p><p>This function simulates the system&#39;s evolution under a driven protocol, performing a Floquet analysis to optimize the phase accumulation. It searches for the flat-top time that best matches the target state, using grid search over phase and amplitude parameters. Diagnostic information about the Floquet frequency and phase is printed during execution.</p>`,10)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[54]||(i[54]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Dynamics/Drives/DriveCalibration.jl#L78-L107",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[54]})]),e("details",j,[e("summary",null,[i[56]||(i[56]=e("a",{id:"SuperconductingCircuits.Dynamics.get_floquet_basis-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}",href:"#SuperconductingCircuits.Dynamics.get_floquet_basis-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.get_floquet_basis")],-1)),i[57]||(i[57]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[59]||(i[59]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_floquet_basis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{qt.QuantumObject, qt.QobjEvo}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, T; t0 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, propagator_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Compute the Floquet basis for a time-periodic Hamiltonian.</p><p><strong>Arguments</strong></p><ul><li><p><code>H::Union{qt.QuantumObject, qt.QobjEvo}</code>: The time-dependent Hamiltonian, either as a quantum object or a time-evolution operator.</p></li><li><p><code>T</code>: The period of the Hamiltonian.</p></li><li><p><code>t0</code>: (optional) Initial time. Defaults to <code>0</code>.</p></li><li><p><code>propagator_kwargs</code>: (optional) Dictionary of keyword arguments to pass to the propagator functions.</p></li></ul><p><strong>Returns</strong></p><ul><li>A tuple containing the Floquet quasi-energies and a function that returns the time-evolved Floquet modes at any given time.</li></ul><p><strong>Description</strong></p><p>This function computes the Floquet basis by:</p><ol><li><p>Calculating the propagator over one period.</p></li><li><p>Diagonalizing the propagator to obtain Floquet quasi-energies and modes.</p></li><li><p>Returning the quasi-energies and a function for propagating the Floquet modes in time.</p></li></ol>',9)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[58]||(i[58]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Dynamics/Floquet/Floquet_Basis.jl#L1-L20",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[58]})]),e("details",F,[e("summary",null,[i[60]||(i[60]=e("a",{id:"SuperconductingCircuits.Dynamics.get_propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}}",href:"#SuperconductingCircuits.Dynamics.get_propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.get_propagator")],-1)),i[61]||(i[61]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[63]||(i[63]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">get_propagator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{qt.QobjEvo, qt.QuantumObject}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Constructs a <code>Propagator</code> object for the given Hamiltonian <code>H</code>, which can be either a <code>qt.QobjEvo</code> or a <code>qt.QuantumObject</code>.</p><p>The returned <code>Propagator</code> provides a function interface to compute the time-evolution operator for <code>H</code> over a specified time interval. The function accepts the final time <code>tf</code>, an optional initial time <code>ti</code> (default is 0), and an optional dictionary of solver keyword arguments <code>solver_kwargs</code>.</p><p><strong>Arguments</strong></p><ul><li><code>H::Union{qt.QobjEvo, qt.QuantumObject}</code>: The Hamiltonian for which the propagator is constructed.</li></ul><p><strong>Returns</strong></p><ul><li><code>Propagator</code>: An object that can be called to compute the propagator for the specified time interval and solver options.</li></ul>',7)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[62]||(i[62]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Dynamics/Utils/Propagator.jl#L57-L69",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[62]})]),e("details",D,[e("summary",null,[i[64]||(i[64]=e("a",{id:"SuperconductingCircuits.Dynamics.propagate_floquet_modes-NTuple{4, Any}",href:"#SuperconductingCircuits.Dynamics.propagate_floquet_modes-NTuple{4, Any}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.propagate_floquet_modes")],-1)),i[65]||(i[65]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[67]||(i[67]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">propagate_floquet_modes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(modes_t0, U, t, T; propagator_kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Symbol, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Propagates a set of Floquet modes from the initial time <code>t₀</code> to a later time <code>t</code> using the provided propagator <code>U</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>modes_t0</code>: Array of Floquet modes at the initial time <code>t₀</code>.</p></li><li><p><code>U</code>: A propagator object with an <code>eval</code> method, used to compute the time evolution operator.</p></li><li><p><code>t</code>: The target time to which the modes should be propagated.</p></li><li><p><code>T</code>: The period of the Floquet system.</p></li><li><p><code>propagator_kwargs</code>: (Optional) Dictionary of keyword arguments to pass to the propagator&#39;s <code>eval</code> method.</p></li></ul><p><strong>Returns</strong></p><ul><li>An array of Floquet modes at time <code>t</code>.</li></ul><p><strong>Notes</strong></p><ul><li><p>If <code>t</code> is an integer multiple of <code>T</code>, the function returns the initial modes unchanged.</p></li><li><p>Otherwise, the function computes the propagator for the time offset <code>t % T</code> and applies it to each mode.</p></li></ul>',8)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[66]||(i[66]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Dynamics/Floquet/Floquet_Utils.jl#L1-L19",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[66]})]),e("details",S,[e("summary",null,[i[68]||(i[68]=e("a",{id:"SuperconductingCircuits.Dynamics.propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}",href:"#SuperconductingCircuits.Dynamics.propagator-Tuple{Union{QuantumToolbox.QuantumObject, QuantumToolbox.QuantumObjectEvolution}, Any}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.propagator")],-1)),i[69]||(i[69]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[71]||(i[71]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">propagator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(H</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Union{qt.QobjEvo, qt.QuantumObject}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, tf; ti </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, solver </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> DE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vern9</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), solver_kwargs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Dict{Any, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>Compute the time-evolution operator (propagator) for a given time-dependent or time-independent Hamiltonian <code>H</code> from initial time <code>ti</code> to final time <code>tf</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>H::Union{qt.QobjEvo, qt.QuantumObject}</code>: The Hamiltonian, either as a time-dependent (<code>qt.QobjEvo</code>) or time-independent (<code>qt.QuantumObject</code>) quantum object.</p></li><li><p><code>tf</code>: The final time for propagation.</p></li><li><p><code>ti</code>: (optional) The initial time. Defaults to <code>0</code>.</p></li><li><p><code>solver</code>: (optional) The ODE solver to use from DifferentialEquations.jl. Defaults to <code>DE.Vern9()</code>.</p></li><li><p><code>solver_kwargs</code>: (optional) Additional keyword arguments to pass to the ODE solver.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>qt.Qobj</code>: The propagator (time-evolution operator) as a quantum object, mapping the system from time <code>ti</code> to <code>tf</code>.</li></ul><p><strong>Notes</strong></p><ul><li><p>The function internally constructs the ODE for the propagator in the Schrödinger picture and solves it using the specified solver.</p></li><li><p>If the Hamiltonian is sparse, the propagator is returned as a sparse matrix.</p></li></ul>',8)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[70]||(i[70]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Dynamics/Utils/Propagator.jl#L18-L36",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[70]})]),e("details",q,[e("summary",null,[i[72]||(i[72]=e("a",{id:"SuperconductingCircuits.Dynamics.Propagator",href:"#SuperconductingCircuits.Dynamics.Propagator"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Dynamics.Propagator")],-1)),i[73]||(i[73]=o()),s(t,{type:"info",class:"jlObjectType jlType",text:"Type"})]),i[75]||(i[75]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Propagator</span></span></code></pre></div><p>A structure representing a quantum propagator for time evolution.</p><p><strong>Fields</strong></p><ul><li><p><code>H::Union{qt.QobjEvo, qt.QuantumObject}</code>: The Hamiltonian or time-dependent operator governing the system&#39;s dynamics. This can be a <code>qt.QobjEvo</code> for time-dependent Hamiltonians or a <code>qt.QuantumObject</code> for time-independent cases.</p></li><li><p><code>eval::Function</code>: A function that computes the propagator or evolves the quantum state, typically as a function of time and initial state.</p></li></ul>',4)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[74]||(i[74]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Dynamics/Utils/Propagator.jl#L3-L11",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[74]})]),i[101]||(i[101]=e("h2",{id:"Utils",tabindex:"-1"},[o("Utils "),e("a",{class:"header-anchor",href:"#Utils","aria-label":'Permalink to "Utils {#Utils}"'},"​")],-1)),e("details",x,[e("summary",null,[i[76]||(i[76]=e("a",{id:"SuperconductingCircuits.Utils.identity_wrapper-Tuple{Dict, Any}",href:"#SuperconductingCircuits.Utils.identity_wrapper-Tuple{Dict, Any}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Utils.identity_wrapper")],-1)),i[77]||(i[77]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[79]||(i[79]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">identity_wrapper</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(𝕀̂_Dict</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, Operator_Dict; order </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [])</span></span></code></pre></div><p>Constructs a tensor product of operators, replacing identity operators with those specified in <code>Operator_Dict</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>𝕀̂_Dict::Dict</code>: A dictionary mapping subsystem keys to identity operators.</p></li><li><p><code>Operator_Dict::Dict</code>: A dictionary mapping subsystem keys to operators that should replace the corresponding identities.</p></li><li><p><code>order::Vector</code> (optional): An array specifying the order of subsystems in the tensor product. If not provided, the order of keys in <code>𝕀̂_Dict</code> is used.</p></li></ul><p><strong>Returns</strong></p><ul><li>The tensor product (using <code>qt.tensor</code>) of the operators, with identities replaced as specified.</li></ul>',6)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[78]||(i[78]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Utils/IdentityWrappers.jl#L1-L13",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[78]})]),e("details",w,[e("summary",null,[i[80]||(i[80]=e("a",{id:"SuperconductingCircuits.Utils.parse_and_eval-Tuple{Any, Any}",href:"#SuperconductingCircuits.Utils.parse_and_eval-Tuple{Any, Any}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Utils.parse_and_eval")],-1)),i[81]||(i[81]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[83]||(i[83]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">parse_and_eval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(expr</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractString</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, x)</span></span></code></pre></div><p>Parses the string <code>expr</code> as a Julia expression, defines a function <code>eval_func(x)</code> that evaluates this expression with the given argument <code>x</code>, and then invokes this function using <code>invokelatest</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>expr::AbstractString</code>: A string representing a Julia expression, which should be valid code involving the variable <code>x</code>.</p></li><li><p><code>x</code>: The value to substitute for <code>x</code> in the evaluated expression.</p></li></ul><p><strong>Returns</strong></p><ul><li>The result of evaluating the parsed expression with the provided value of <code>x</code>.</li></ul>',6)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[82]||(i[82]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Utils/RandomThings.jl#L18-L29",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[82]})]),e("details",O,[e("summary",null,[i[84]||(i[84]=e("a",{id:"SuperconductingCircuits.Utils.state_tracker-Tuple{Vector, Dict}",href:"#SuperconductingCircuits.Utils.state_tracker-Tuple{Vector, Dict}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Utils.state_tracker")],-1)),i[85]||(i[85]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[87]||(i[87]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">state_tracker</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(state_history</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, states_to_track</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; other_sorts</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Dict{Any, Any}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), use_logging</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Tracks the evolution of specified quantum states across a sequence of state histories.</p><p><strong>Arguments</strong></p><ul><li><p><code>state_history::Vector</code>: A vector where each element is a collection (e.g., vector or array) of quantum states at a given time step.</p></li><li><p><code>states_to_track::Dict</code>: A dictionary mapping state identifiers to their initial state vectors to be tracked.</p></li><li><p><code>other_sorts::Dict{Any, Any}</code> (optional): A dictionary mapping additional property names to arrays of properties, which are also tracked for each state and time step. Defaults to an empty dictionary.</p></li><li><p><code>use_logging::Bool</code> (optional): If <code>true</code>, enables debug and info logging for tracking progress and overlaps. Defaults to <code>true</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><code>history</code>: A multidimensional array (AxisArray or similar) indexed by state and step, where each entry is a dictionary containing: <ul><li><p><code>&quot;psi&quot;</code>: The tracked state vector at that step.</p></li><li><p><code>&quot;overlap&quot;</code>: The maximum overlap value found for the state at that step.</p></li><li><p>Additional keys for each property in <code>other_sorts</code>, containing their respective values.</p></li></ul></li></ul><p><strong>Description</strong></p><p>For each state specified in <code>states_to_track</code>, the function iteratively finds, at each time step, the state in <code>state_history</code> with the maximum overlap (squared inner product) with the previous step&#39;s tracked state. It records the state vector, overlap, and any additional properties provided in <code>other_sorts</code>. The function also ensures that the same state is not assigned to multiple tracked states at the same step, logging a warning if this occurs.</p>',8)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[86]||(i[86]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Utils/StateTracking.jl#L1-L20",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[86]})]),e("details",B,[e("summary",null,[i[88]||(i[88]=e("a",{id:"SuperconductingCircuits.Utils.tostr-Tuple{Any}",href:"#SuperconductingCircuits.Utils.tostr-Tuple{Any}"},[e("span",{class:"jlbinding"},"SuperconductingCircuits.Utils.tostr")],-1)),i[89]||(i[89]=o()),s(t,{type:"info",class:"jlObjectType jlMethod",text:"Method"})]),i[91]||(i[91]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">tostr</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String</span></span></code></pre></div><p>Converts the given object <code>obj</code> to its plain text string representation by using the <code>show</code> function with the <code>&quot;text/plain&quot;</code> MIME type.</p><p><strong>Arguments</strong></p><ul><li><code>obj</code>: Any Julia object to be converted to a string.</li></ul><p><strong>Returns</strong></p><ul><li><code>String</code>: The plain text representation of <code>obj</code>.</li></ul>',6)),s(t,{type:"info",class:"source-link",text:"source"},{default:a(()=>i[90]||(i[90]=[e("a",{href:"https://github.com/Gavin-Rockwood/SuperconductingCircuits.jl/blob/70c61feb3bee0501a15e86e1486e232612cae531/src/Utils/RandomThings.jl#L1-L11",target:"_blank",rel:"noreferrer"},"source",-1)])),_:1,__:[90]})])])}const N=r(d,[["render",R]]);export{U as __pageData,N as default};
